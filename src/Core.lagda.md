# Syntax

```
module Core where

open import Utils
open import Type
```

In this section, we define the syntax of the calculus,
renaming, substitution, and prove some related lemmas.

## Contexts and Variables

The context is represented as a snoc list of types,
and variables are de Bruijn indices, indexing into that list.

```
infixl 5 _▷_

data Context : Set where
  ∅   : Context
  _▷_ : Context → Type → Context

infix  4 _∋_
infix  9 S_

data _∋_ : Context → Type → Set where

  Z : ∀ {Γ A}
      ----------
    → Γ ▷ A ∋ A

  S_ : ∀ {Γ A B}
    → Γ ∋ A
      ---------
    → Γ ▷ B ∋ A
```

## Terms

The type of terms `_⊢_` is defined recursively with the type of handlers
`_⊢_➡_`. In order to streamline this presentation, we will interleave
term constructor declarations with related definitions.
This is allowed in an `interleaved mutual` block, which Agda desugars by
deinterleaving them.

```
interleaved mutual

  infix  5 ƛ_
  infix  4 _⊢_
  infix  4 _⊢_➡_
  infixl  6 _·_
  infix  6 _⦅_⦆_
  infix  8 `_
```

```
  data _⊢_ : Context → Typeᶜ → Set
  record _⊢_➡_ (Γ : Context) (P Q : Typeᶜ) : Set
```

The data type `Γ ⊢ P` represents a term of computation type `P` in context `Γ`.
The first five typing rules are standard (variables, abstraction, application,
constants, and primitive operators). Then three typing rules extend the
calculus with gradual typing (casts, boxes, and blame), and two more with
algebraic effects (operations and handlers).

\lyx{Explain this syntax}
```
  data _ where
```

Variables are to be substituted with values (hence they have value types),
so they perform no operations.

There are several possible ways to formulate the typing rules for variables
and values (abstractions, constants, and boxes).

\begin{itemize}
 \item Variables and values have an unconstrained effect parameter `E`.
  This is the way it currently works.
 \item Variables and/or values have the empty effect `ε`. This requires a notion
  of effect subtyping in order to use variables and values in effectful contexts.
 \begin{itemize}
  \item When variables have an empty effect, they will generally be wrapped in
   a subtyping cast `ε ⊑ᵉ E`
 \end{itemize}
\end{itemize}

```
    `_ : ∀ {Γ E A}
      →  Γ ∋ A
         -----------
      →  Γ ⊢ ⟨ E ⟩ A
```

The typing rule for abstractions extends the standard rule from
the simply-typed calculus with additional effects annotations.
We must distinguish the effect `E` when the function is constructed
(no operations are performed, so `E` is unconstrained), from the
effect `F` when the function is applied (whatever effects are
performed by the body of the function).

```
    ƛ_ :  ∀ {Γ E F B A}
      →  Γ ▷ A ⊢ ⟨ F ⟩ B
         -----------------------
      →  Γ ⊢ ⟨ E ⟩ (A ⇒ ⟨ F ⟩ B)
```

Applications ensure that the effect of the function matches the ambient one `E`.

```
    _·_ : ∀ {Γ E A B}
      →  Γ ⊢ ⟨ E ⟩ (A ⇒ ⟨ E ⟩ B)
      →  Γ ⊢ ⟨ E ⟩ A
         -----------------------
      →  Γ ⊢ ⟨ E ⟩ B
```

Primitive constants (`true`, `false`, `n ∈ ℕ`)
and operators (`_||_`, `_+_`).

```
    $_ : ∀ {Γ E ι}
      →  rep ι
         -------
      →  Γ ⊢ ⟨ E ⟩ ($ ι)

    _⦅_⦆_ : ∀ {Γ E ι ι′ ι″}
      →  Γ ⊢ ⟨ E ⟩ ($ ι)
      →  (rep ι → rep ι′ → rep ι″)
      →  Γ ⊢ ⟨ E ⟩ ($ ι′)
         -------------------------
      →  Γ ⊢ ⟨ E ⟩ ($ ι″)
```

A cast between computation types `P` to `Q` checks
during run time that the inner computation, of type `P`,
behaves like a computation of type `Q`: the operations
performed by the inner computation must belong to the effect
of `Q`, and the resulting value is to be wrapped or unwrapped
according to the return type of `Q`.

Note how casts looks similar to handlers (defined below).

```
    cast : ∀ {Γ P Q}
      →  P =>ᶜ Q
      →  Γ ⊢ P
         -------
      →  Γ ⊢ Q
```

A \emph{box} `(M ⇑ g)` constructs a value of the dynamic type `★`:
it is a pair of a typed term `M` and a "tag" `g` which is to be
inspected by run-time downcasts.
It is generated by casts to `★`.

```
    _⇑_ : ∀ {Γ G E}
      →  Γ ⊢ ⟨ E ⟩ G
      →  Ground G
         -----------
      →  Γ ⊢ ⟨ E ⟩ ★
```

When a cast fails, it raises `blame`.

```
    blame : ∀ {Γ A}
         -----
      →  Γ ⊢ A
```

A computation `perform e M` performs an operation `e` with arguments (request) `M`,
returning a response of type `response e`.

We use the standard technique of \emph{fording}~\citep{mcbride2000},
where we replace `response e` as an index in the result type of `perform-`
with a fresh variable `A` and a propositional equality `response e ≡ A`.

```
    perform- : ∀ {Γ E e A}
      →  e ∈☆ E
      →  Γ ⊢ ⟨ E ⟩ request e
      →  response e ≡ A
         --------------------
      →  Γ ⊢ ⟨ E ⟩ A
```

A pattern synonym to hide the equality argument in `perform-`.
```
  pattern perform e∈E M = perform- e∈E M refl
```

Whereas functions are essentially maps between value types,
handlers are maps between computation types `P ➡ Q`,
whose syntax is defined below.

```
  data _ where

    handle : ∀ {Γ P Q}
      →  _⊢_➡_ Γ P Q
      →  Γ ⊢ P
         -----------
      →  Γ ⊢ Q
```

A handler `H : Γ ⊢ P ➡ Q` consists of: a list of operations it handles (`Hooks`),
which will be subtracted from the effects of the inner computation
(`Hooks-handled`); a \emph{return clause} (`on-return`), which is a continuation
to be called when the inner computation returns a value; and
a list of \emph{operation clauses} (`on-perform`), one for every operation in `Hooks`.
We collect those components in a record.

The type of operation clauses is given by the auxiliary definition `On-Perform`.
`All` is the type of list indexed by lists.

```
  On-Perform : Context → Typeᶜ → List Op → Set
  On-Perform Γ Q Hooks = All (λ e → Γ ▷ request e ▷ (response e ⇒ Q) ⊢ Q) Hooks

  record _⊢_➡_ Γ P Q where
    inductive
    open Typeᶜ
    field
      Hooks : List Op
      Hooks-handled : P .effects ≡ (Hooks ++☆ Q .effects)
      on-return : Γ ▷ P .returns ⊢ Q
      on-perform : On-Perform Γ Q Hooks

  open _⊢_➡_ public
```

## Substitutions

Substitutions in terms using de Bruijn indices are defined in two steps:
renaming first, substitution second.

### Renaming maps, substitution maps, term maps

Renaming and substitution change the context of terms, but not their types.
We can view them as arrows between contexts, forming categories, which
suggests the following notations.

```
infix 4 _→ᴿ_ _→ˢ_ _→ᵀ_ _→ʰ_
```

Renaming maps: maps from variables to variables in another context.
```
_→ᴿ_ : Context → Context → Set
Γ →ᴿ Δ = ∀ {A} → Γ ∋ A → Δ ∋ A
```

Substitution maps: maps from variables to terms in another context.
```
_→ˢ_ : Context → Context → Set
Γ →ˢ Δ = ∀ {E A} → Γ ∋ A → Δ ⊢ ⟨ E ⟩ A
```

Term maps: maps from terms to terms, changing their context.
```
_→ᵀ_ : Context → Context → Set
Γ →ᵀ Δ = ∀ {A} → Γ ⊢ A → Δ ⊢ A
```

Handler maps: maps from handlers to handlers, changing their context.
```
_→ʰ_ : Context → Context → Set
Γ →ʰ Δ = ∀ {P Q} → Γ ⊢ P ➡ Q → Δ ⊢ P ➡ Q
```

### Renaming

The main motivation for renaming is to define `lift`, also known as weakening,
an operator that extends the context of a term with an unused variable.

Extension of renaming maps
```
ren▷ : ∀ {Γ Δ A}
  → (Γ →ᴿ Δ)
    ----------------------------
  → ((Γ ▷ A) →ᴿ (Δ ▷ A))
ren▷ ρ Z      =  Z
ren▷ ρ (S x)  =  S (ρ x)
```

Renaming (and substitution) follow the structure of the type of terms.
In particular, it is defined mutually recursively with the type of handlers
and perform clauses, so we declare a renaming function for each of those constructs.

```
ren : ∀ {Γ Δ}
  →  (Γ →ᴿ Δ)
     --------
  →  (Γ →ᵀ Δ)

renʰ : ∀ {Γ Δ}
  →  (Γ →ᴿ Δ)
  →  (Γ →ʰ Δ)
ren-on-perform : ∀ {Γ Δ}
  →  (Γ →ᴿ Δ)
  →  ∀ {Q Hooks} → On-Perform Γ Q Hooks → On-Perform Δ Q Hooks
```

The term-renaming function `ren` hides no surprises. Under an abstraction,
`ren▷` extends the renaming map `ρ` with the newly bound variable.
And of course a handler is renamed using `renʰ`.
```
ren ρ (` x)                =  ` (ρ x)
ren ρ (ƛ N)                =  ƛ (ren (ren▷ ρ) N)
ren ρ (L · M)              =  (ren ρ L) · (ren ρ M)
ren ρ ($ k)                =  $ k
ren ρ (L ⦅ _⊕_ ⦆ M)        =  (ren ρ L) ⦅ _⊕_ ⦆ (ren ρ M)
ren ρ (M ⇑ g)              =  (ren ρ M) ⇑ g
ren ρ (cast ±p M)          =  cast ±p (ren ρ M)
ren ρ blame                =  blame
ren ρ (perform- e∈E M eq)  =  perform- e∈E (ren ρ M) eq
ren ρ (handle H M)         =  handle (renʰ ρ H) (ren ρ M)
```

Renaming a handler is similarly straightforward: rename each field,
as is appropriate.
```
renʰ ρ H = record
  { Hooks = Hooks H
  ; Hooks-handled = Hooks-handled H
  ; on-return = ren (ren▷ ρ) (on-return H)
  ; on-perform = ren-on-perform ρ (on-perform H) }
```

Since operation clauses are lists (indexed by lists),
renaming merely maps `ren` on every element. However,
the termination checker will not let us use a `map` combinator.
We must duplicate the logic of `map` to satisfy the termination checker.
```
ren-on-perform ρ [] = []
ren-on-perform ρ (M ∷ Ms) = ren (ren▷ (ren▷ ρ)) M ∷ ren-on-perform ρ Ms
```

Finally, we obtain `lift`, which let us define substitution.
```
lift : ∀ {Γ : Context} {A : Type} → Γ →ᵀ (Γ ▷ A)
lift = ren S_
```

### Substitution

The definition of substitution imitates renaming.
The main difference is in the variable case:
`ren` constructs another variable `\` ρ x`, whereas `sub`
returns the term produced by the substitution map `σ x`.
Moreover, the extension function `sub▷` uses `lift`,
which we just defined in terms of renaming.

```
sub▷ : ∀ {Γ Δ A}
  → (Γ →ˢ Δ)
    --------------------------
  → ((Γ ▷ A) →ˢ (Δ ▷ A))
sub▷ σ Z      =  ` Z
sub▷ σ (S x)  =  lift (σ x)
```

```
sub : ∀ {Γ Δ : Context}
  → (Γ →ˢ Δ)
    --------
  → (Γ →ᵀ Δ)

subʰ : ∀ {Γ Δ} → (Γ →ˢ Δ) → (Γ →ʰ Δ)
sub-on-perform : ∀ {Γ Δ} → (Γ →ˢ Δ) → ∀ {Q Hooks} → On-Perform Γ Q Hooks → On-Perform Δ Q Hooks

sub σ (` x)                =  σ x
sub σ (ƛ  N)               =  ƛ (sub (sub▷ σ) N)
sub σ (L · M)              =  (sub σ L) · (sub σ M)
sub σ ($ k)                =  $ k
sub σ (L ⦅ _⊕_ ⦆ M)        =  (sub σ L) ⦅ _⊕_ ⦆ (sub σ M)
sub σ (M ⇑ g)              =  (sub σ M) ⇑ g
sub σ (cast ±p M)          =  cast ±p (sub σ M)
sub σ blame                =  blame
sub σ (perform- e∈E M eq)  =  perform- e∈E (sub σ M) eq
sub σ (handle H M)         =  handle (subʰ σ H) (sub σ M)

subʰ σ H = record
  { Hooks = Hooks H
  ; Hooks-handled = Hooks-handled H
  ; on-return = sub (sub▷ σ) (on-return H)
  ; on-perform = sub-on-perform σ (on-perform H) }

sub-on-perform σ [] = []
sub-on-perform σ (M ∷ Ms) = sub (sub▷ (sub▷ σ)) M ∷ sub-on-perform σ Ms
```

`sub` implements the simultaneous substitution of multiple variables.
A special case used in the `β` rule is the substitution of a single variable,
the last one in the context. This operation is denoted `_[_]`.
```
σ₀ : ∀ {Γ A} → (M : ∀ {E} → Γ ⊢ ⟨ E ⟩ A) → (Γ ▷ A) →ˢ Γ
σ₀ M Z      =  M
σ₀ M (S x)  =  ` x

_[_] : ∀ {Γ P A}
     →  Γ ▷ A ⊢ P
     →  (∀ {E} → Γ ⊢ ⟨ E ⟩ A)
        ---------
     →  Γ ⊢ P
_[_] {Γ} {P} {A} N M =  sub {Γ ▷ A} {Γ} (σ₀ M) N
```

### Composition and identity

Composing two renamings successively is equivalent to a single renaming with
a composed renaming map (`ren∘ren`).
Intuitively, we could write `ren ρ ∘ ren ρ′ ≡ ren (ρ ∘ ρ′)`.
\lyx{can we actually write that?}

We prove similar lemmas `sub∘ren`, `ren∘sub`, and `lift∘sub` for composing
renaming and substitution.

\lyx{There's a lot of code here I don't know what to comment about it.}

```
ren∘ren▷ : ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {ρ″ : Γ →ᴿ Γ″}
  → (∀ {A} (x : Γ ∋ A) → ρ′ (ρ x) ≡ ρ″ x)
    --------------------------------------------------------------
  → (∀ {B A} (x : Γ ▷ B ∋ A) → ren▷ ρ′ (ren▷ ρ x) ≡ ren▷ ρ″ x)
ren∘ren▷ ρ∘ Z      =  refl
ren∘ren▷ ρ∘ (S x)  =  cong S_ (ρ∘ x)

ren∘ren : ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {ρ″ : Γ →ᴿ Γ″}
  → (∀ {A} (x : Γ ∋ A) → ρ′ (ρ x) ≡ ρ″ x)
    -------------------------------------------------
  → (∀ {A} (M : Γ ⊢ A) → ren ρ′ (ren ρ M) ≡ ren ρ″ M)

ren∘ren-on-perform :  ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {ρ″ : Γ →ᴿ Γ″}
  → (∀ {A} (x : Γ ∋ A) → ρ′ (ρ x) ≡ ρ″ x)
    -------------------------------------------------
  → (∀ {Hooks Q} (H : On-Perform Γ Q Hooks)
     → ren-on-perform ρ′ (ren-on-perform ρ H) ≡ ren-on-perform ρ″ H)
ren∘ren-on-perform ρ≡ [] = refl
ren∘ren-on-perform ρ≡ (M ∷ Ms)
  = cong₂ _∷_ (ren∘ren (ren∘ren▷ (ren∘ren▷ ρ≡)) M) (ren∘ren-on-perform ρ≡ Ms)

ren∘renʰ :  ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {ρ″ : Γ →ᴿ Γ″}
  → (∀ {A} (x : Γ ∋ A) → ρ′ (ρ x) ≡ ρ″ x)
    -------------------------------------------------
  → (∀ {P Q} (H : Γ ⊢ P ➡ Q) → renʰ ρ′ (renʰ ρ H) ≡ renʰ ρ″ H)
ren∘renʰ ρ≡ H = cong₂
  (λ M Ns → record { on-return = M ; on-perform = Ns })
  (ren∘ren (ren∘ren▷ ρ≡) (on-return H)) (ren∘ren-on-perform ρ≡ (on-perform H))

ren∘ren ρ≡ (` x)                =  cong `_ (ρ≡ x)
ren∘ren ρ≡ (ƛ N)                =  cong ƛ_ (ren∘ren (ren∘ren▷ ρ≡) N)
ren∘ren ρ≡ (L · M)              =  cong₂ _·_ (ren∘ren ρ≡ L) (ren∘ren ρ≡ M)
ren∘ren ρ≡ ($ k)                =  refl
ren∘ren ρ≡ (L ⦅ _⊕_ ⦆ M)        =  cong₂ _⦅ _⊕_ ⦆_ (ren∘ren ρ≡ L) (ren∘ren ρ≡ M)
ren∘ren ρ≡ (M ⇑ g)              =  cong (_⇑ g) (ren∘ren ρ≡ M)
ren∘ren ρ≡ (cast ±p M)          =  cong (cast ±p) (ren∘ren ρ≡ M)
ren∘ren ρ≡ blame                =  refl
ren∘ren ρ≡ (perform- e∈E M eq)  =  cong (λ M → perform- e∈E M eq) (ren∘ren ρ≡ M)
ren∘ren {ρ = ρ} {ρ′ = ρ′} ρ≡ (handle H M)
  = cong₂ handle (ren∘renʰ {ρ = ρ} {ρ′ = ρ′} ρ≡ H) (ren∘ren ρ≡ M)

lift∘ren : ∀ {Γ Δ A B} (ρ : Γ →ᴿ Δ) (M : Γ ⊢ B)
  → lift {A = A} (ren ρ M) ≡ ren (ren▷ ρ) (lift {A = A} M)
lift∘ren {Γ} ρ M  =  trans (ren∘ren ρ≡₁ M) (sym (ren∘ren ρ≡₂ M))
  where
  ρ≡₁ : ∀ {A} (x : Γ ∋ A) → S (ρ x) ≡ S (ρ x)
  ρ≡₁ x = refl
  ρ≡₂ : ∀ {A} (x : Γ ∋ A) → ren▷ ρ (S x) ≡ S (ρ x)
  ρ≡₂ Z     = refl
  ρ≡₂ (S x) = refl

sub∘ren▷ : ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {σ′ : Γ′ →ˢ Γ″} {σ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → σ′ {E} (ρ x) ≡ σ″ x)
    ----------------------------------------------------------
  → (∀ {E B A} (x : Γ ▷ B ∋ A) → sub▷ σ′ {E} (ren▷ ρ x) ≡ sub▷ σ″ x)
sub∘ren▷ σ≡ Z      =  refl
sub∘ren▷ σ≡ (S x)  =  cong (ren S_) (σ≡ x)

sub∘ren : ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {σ′ : Γ′ →ˢ Γ″} {σ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → σ′ {E} (ρ x) ≡ σ″ x)
    ----------------------------------------------------------
  → (∀ {A} (M : Γ ⊢ A) → sub σ′ (ren ρ M) ≡ sub σ″ M)

sub∘ren-on-perform :  ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {σ′ : Γ′ →ˢ Γ″} {σ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → σ′ {E} (ρ x) ≡ σ″ x)
    -------------------------------------------------
  → (∀ {Hooks Q} (H : On-Perform Γ Q Hooks)
     → sub-on-perform σ′ (ren-on-perform ρ H) ≡ sub-on-perform σ″ H)
sub∘ren-on-perform ρ≡ [] = refl
sub∘ren-on-perform ρ≡ (M ∷ Ms)
  = cong₂ _∷_ (sub∘ren (sub∘ren▷ (sub∘ren▷ ρ≡)) M) (sub∘ren-on-perform ρ≡ Ms)

sub∘renʰ :  ∀ {Γ Γ′ Γ″} {ρ : Γ →ᴿ Γ′} {σ′ : Γ′ →ˢ Γ″} {σ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → σ′ {E} (ρ x) ≡ σ″ x)
    -------------------------------------------------
  → (∀ {P Q} (H : Γ ⊢ P ➡ Q) → subʰ σ′ (renʰ ρ H) ≡ subʰ σ″ H)
sub∘renʰ ρ≡ H = cong₂
  (λ M Ns → record { on-return = M ; on-perform = Ns })
  (sub∘ren (sub∘ren▷ ρ≡) (on-return H))
  (sub∘ren-on-perform ρ≡ (on-perform H))

sub∘ren σ≡ (` x)                =  σ≡ x
sub∘ren σ≡ (ƛ N)                =  cong ƛ_ (sub∘ren (sub∘ren▷ σ≡) N)
sub∘ren σ≡ (L · M)              =  cong₂ _·_ (sub∘ren σ≡ L) (sub∘ren σ≡ M)
sub∘ren σ≡ ($ k)                =  refl
sub∘ren σ≡ (L ⦅ _⊕_ ⦆ M)        =  cong₂ _⦅ _⊕_ ⦆_ (sub∘ren σ≡ L) (sub∘ren σ≡ M)
sub∘ren σ≡ (M ⇑ g)              =  cong (_⇑ g) (sub∘ren σ≡ M)
sub∘ren σ≡ (cast ±p M)          =  cong (cast ±p) (sub∘ren σ≡ M)
sub∘ren σ≡ blame                =  refl
sub∘ren ρ≡ (perform- e∈E M eq)  =  cong (λ M → perform- e∈E M eq) (sub∘ren ρ≡ M)
sub∘ren {ρ = ρ} {σ′ = σ′} ρ≡ (handle H M)
  = cong₂ handle (sub∘renʰ {ρ = ρ} {σ′ = σ′} ρ≡ H) (sub∘ren ρ≡ M)

ren∘sub▷ : ∀ {Γ Γ′ Γ″} {σ : Γ →ˢ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {σ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → ren ρ′ (σ {E} x) ≡ σ″ x)
    -------------------------------------------------------------------
  → (∀ {E B A} (x : Γ ▷ B ∋ A) → ren (ren▷ ρ′) (sub▷ σ {E} x) ≡ sub▷ σ″ x)
ren∘sub▷ σ≡ Z      =  refl
ren∘sub▷ {Γ′ = Γ′} {σ = σ} {ρ′ = ρ′} σ≡ {B = B} (S x)  =
    trans (trans (ren∘ren ρ∘₁ (σ x))
                 (sym (ren∘ren ρ∘₂ (σ x))))
          (cong (ren S_) (σ≡ x))
  where
  ρ∘₁ : ∀ {A} (x : Γ′ ∋ A) → ren▷ {A = B} ρ′ (S_ x) ≡ S (ρ′ x)
  ρ∘₁ x = refl

  ρ∘₂ : ∀ {A} (x : Γ′ ∋ A) → S_ {B = B} (ρ′ x) ≡ S (ρ′ x)
  ρ∘₂ x = refl

ren∘sub : ∀ {Γ Γ′ Γ″} {σ : Γ →ˢ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {σ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → ren ρ′ (σ {E} x) ≡ σ″ x)
    --------------------------------------------------------
  → (∀ {A} (M : Γ ⊢ A) → ren ρ′ (sub σ M) ≡ sub σ″ M)

ren∘sub-on-perform :  ∀ {Γ Γ′ Γ″} {ρ : Γ →ˢ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {ρ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → ren ρ′ (ρ {E} x) ≡ ρ″ x)
    -------------------------------------------------
  → (∀ {Hooks Q} (H : On-Perform Γ Q Hooks)
     → ren-on-perform ρ′ (sub-on-perform ρ H) ≡ sub-on-perform ρ″ H)
ren∘sub-on-perform ρ≡ [] = refl
ren∘sub-on-perform ρ≡ (M ∷ Ms)
  = cong₂ _∷_ (ren∘sub (ren∘sub▷ (ren∘sub▷ ρ≡)) M) (ren∘sub-on-perform ρ≡ Ms)

ren∘subʰ :  ∀ {Γ Γ′ Γ″} {σ : Γ →ˢ Γ′} {ρ′ : Γ′ →ᴿ Γ″} {σ″ : Γ →ˢ Γ″}
  → (∀ {E A} (x : Γ ∋ A) → ren ρ′ (σ {E} x) ≡ σ″ x)
    -------------------------------------------------
  → (∀ {P Q} (H : Γ ⊢ P ➡ Q) → renʰ ρ′ (subʰ σ H) ≡ subʰ σ″ H)
ren∘subʰ ρ≡ H = cong₂
  (λ M Ns → record { on-return = M ; on-perform = Ns })
  (ren∘sub (ren∘sub▷ ρ≡) (on-return H))
  (ren∘sub-on-perform ρ≡ (on-perform H))

ren∘sub σ≡ (` x)          =  σ≡ x
ren∘sub σ≡ (ƛ N)          =  cong ƛ_ (ren∘sub (ren∘sub▷ σ≡) N)
ren∘sub σ≡ (L · M)        =  cong₂ _·_ (ren∘sub σ≡ L) (ren∘sub σ≡ M)
ren∘sub σ≡ ($ k)          =  refl
ren∘sub σ≡ (L ⦅ _⊕_ ⦆ M)  =  cong₂ _⦅ _⊕_ ⦆_ (ren∘sub σ≡ L) (ren∘sub σ≡ M)
ren∘sub σ≡ (M ⇑ g)        =  cong (_⇑ g) (ren∘sub σ≡ M)
ren∘sub σ≡ (cast ±p M)    =  cong (cast ±p) (ren∘sub σ≡ M)
ren∘sub σ≡ blame          =  refl
ren∘sub ρ≡ (handle H M)   =  cong₂ handle (ren∘subʰ ρ≡ H) (ren∘sub ρ≡ M)
ren∘sub ρ≡ (perform- e∈E M eq) = cong (λ M → perform- e∈E M eq) (ren∘sub ρ≡ M)

lift∘sub : ∀ {Γ Δ A B} (σ : Γ →ˢ Δ) (M : Γ ⊢ B)
  → lift {A = A} (sub σ M) ≡ sub (sub▷ σ) (lift {A = A} M)
lift∘sub {Γ} σ M  =  trans (ren∘sub σ≡₁ M) (sym (sub∘ren σ≡₂ M))
  where
  σ≡₁ : ∀ {A E} (x : Γ ∋ A) → lift (σ {E} x) ≡ lift (σ x)
  σ≡₁ x = refl
  σ≡₂ : ∀ {A E} (x : Γ ∋ A) → sub▷ σ {E} (S x) ≡ lift (σ x)
  σ≡₂ Z     = refl
  σ≡₂ (S x) = refl
```

### Renaming and substitution by identity is the identity

```
Idᴿ : ∀ {Γ} → (ρ : Γ →ᴿ Γ) → Set
Idᴿ {Γ} ρ  =  ∀ {A} (x : Γ ∋ A) → ρ x ≡ x

Idˢ : ∀ {Γ} → (σ : Γ →ˢ Γ) → Set
Idˢ {Γ} σ  =  ∀ {E A} (x : Γ ∋ A) → σ {E} x ≡ ` x

Idᵀ : ∀ {Γ} → (θ : Γ →ᵀ Γ) → Set
Idᵀ {Γ} θ  =  ∀ {A} (M : Γ ⊢ A) → θ M ≡ M

Idʰ : ∀ {Γ} → (θ : Γ →ʰ Γ) → Set
Idʰ {Γ} θ  =  ∀ {P Q} (H : Γ ⊢ P ➡ Q) → θ H ≡ H

Id-on-perform : ∀ {Γ}
  → (θ : ∀ {Hooks Q} → On-Perform Γ Q Hooks → On-Perform Γ Q Hooks) → Set
Id-on-perform {Γ} θ  =  ∀ {Hooks Q} (H : On-Perform Γ Q Hooks) → θ H ≡ H

renId▷ : ∀ {Γ} {ρ : Γ →ᴿ Γ}
  → Idᴿ {Γ} ρ
    ----------------------------
  → ∀ {A} → Idᴿ {Γ ▷ A} (ren▷ ρ)
renId▷ ρId Z                    =  refl
renId▷ ρId (S x) rewrite ρId x  =  refl

renId : ∀ {Γ} {ρ : Γ →ᴿ Γ}
  → Idᴿ ρ
    -------------
  → Idᵀ (ren ρ)

renId-on-perform : ∀ {Γ} {ρ : Γ →ᴿ Γ}
  → Idᴿ ρ
    -------------
  → Id-on-perform (ren-on-perform ρ)
renId-on-perform ρId [] = refl
renId-on-perform ρId (M ∷ Ms)
  = cong₂ _∷_ (renId (renId▷ (renId▷ ρId)) M) (renId-on-perform ρId Ms)

renIdʰ : ∀ {Γ} {ρ : Γ →ᴿ Γ}
  → Idᴿ ρ
    -------------
  → Idʰ (renʰ ρ)
renIdʰ ρId H = cong₂ (λ M Ns → record { on-return = M ; on-perform = Ns })
                     (renId (renId▷ ρId) (on-return H))
                     (renId-on-perform ρId (on-perform H))
  where open _⊢_➡_ H

renId ρId (` x) rewrite ρId x                               =  refl
renId ρId (ƛ M) rewrite renId (renId▷ ρId) M                =  refl
renId ρId (L · M) rewrite renId ρId L | renId ρId M         =  refl
renId ρId ($ k)                                             =  refl
renId ρId (L ⦅ _⊕_ ⦆ M) rewrite renId ρId L | renId ρId M   =  refl
renId ρId (M ⇑ g) rewrite renId ρId M                       =  refl
renId ρId (cast ±p M) rewrite renId ρId M                   =  refl
renId ρId blame                                             =  refl
renId ρId (perform- e∈E M eq) rewrite renId ρId M           =  refl
renId ρId (handle H M) rewrite renIdʰ ρId H | renId ρId M   =  refl

subId▷ : ∀ {Γ} {σ : Γ →ˢ Γ}
  → Idˢ {Γ} σ
    ----------------------------
  → ∀ {A} → Idˢ {Γ ▷ A} (sub▷ σ)
subId▷ σId Z                    =  refl
subId▷ σId {A} {E} (S x) rewrite σId {E} x  =  refl

subId : ∀ {Γ} {σ : Γ →ˢ Γ}
  → Idˢ σ
    -------------
  → Idᵀ (sub σ)

subId-on-perform : ∀ {Γ} {ρ : Γ →ˢ Γ}
  → Idˢ ρ
    -------------
  → Id-on-perform (sub-on-perform ρ)
subId-on-perform ρId [] = refl
subId-on-perform ρId (M ∷ Ms)
  = cong₂ _∷_ (subId (subId▷ (subId▷ ρId)) M) (subId-on-perform ρId Ms)

subIdʰ : ∀ {Γ} {σ : Γ →ˢ Γ}
  → Idˢ σ
    -------------
  → Idʰ (subʰ σ)
subIdʰ ρId H = cong₂
  (λ M Ns → record { on-return = M ; on-perform = Ns })
  (subId (subId▷ ρId) (on-return H))
  (subId-on-perform ρId (on-perform H))
  where open _⊢_➡_ H

subId σId {⟨ E ⟩ _} (` x) rewrite σId {E} x                 =  refl
subId σId (ƛ M) rewrite subId (subId▷ σId) M                =  refl
subId σId (L · M) rewrite subId σId L | subId σId M         =  refl
subId σId ($ k)                                             =  refl
subId σId (L ⦅ _⊕_ ⦆ M) rewrite subId σId L | subId σId M   =  refl
subId σId (M ⇑ g) rewrite subId σId M                       =  refl
subId σId (cast ±p M) rewrite subId σId M                   =  refl
subId σId blame                                             =  refl
subId σId (perform- e∈E M eq) rewrite subId σId M           =  refl
subId ρId (handle H M) rewrite subIdʰ ρId H | subId ρId M   =  refl
```

## Values

The values of our calculus are abstractions, constants, and boxes,
as defined by the `Value` predicate.
```
data Value {Γ E} : ∀ {A} → Γ ⊢ ⟨ E ⟩ A → Set where

  ƛ_ : ∀ {F A B}
    →  (N : Γ ▷ A ⊢ ⟨ F ⟩ B)
       ---------------
    →  Value (ƛ N)

  $_ : ∀ {ι}
    →  (k : rep ι)
       -------------------
    →  Value ($ k)

  _⇑_ : ∀{G}{V : Γ ⊢ ⟨ E ⟩ G}
    →  (v : Value V)
    →  (g : Ground G)
       ------------------
    →  Value (V ⇑ g)
```

Extract term from evidence that it is a value.
```
value : ∀ {Γ P} {V : Γ ⊢ P} → Value V → Γ ⊢ P
value {V = V} _ = V
```

Values won't reduce. In particular, they don't perform any effect.
The `gvalue` function generalizes a value to any effect.
```
gvalue : ∀ {Γ E A} {V : Γ ⊢ ⟨ E ⟩ A}
  → (v : Value V)
    -------------
  → ∀ {F} → Γ ⊢ ⟨ F ⟩ A
gvalue (ƛ N)  =  ƛ N
gvalue ($ k)  =  $ k
gvalue (V ⇑ g) = gvalue V ⇑ g
```

Renaming preserves values
```
ren-val : ∀ {Γ Δ E A} {V : Γ ⊢ ⟨ E ⟩ A}
  → (ρ : Γ →ᴿ Δ)
  → Value V
    ------------------
  → Value (ren ρ V)
ren-val ρ (ƛ N)    =  ƛ (ren (ren▷ ρ) N)
ren-val ρ ($ k)    =  $ k
ren-val ρ (V ⇑ g)  =  (ren-val ρ V) ⇑ g
```

Substitution preserves values
```
sub-val : ∀ {Γ Δ A} {V : Γ ⊢ ⟨ ε ⟩ A}
  → (σ : Γ →ˢ Δ)
  → Value V
    ------------------
  → Value (sub σ V)
sub-val σ (ƛ N)    =  ƛ (sub (sub▷ σ) N)
sub-val σ ($ k)    =  $ k
sub-val σ (V ⇑ g)  =  (sub-val σ V) ⇑ g
```
