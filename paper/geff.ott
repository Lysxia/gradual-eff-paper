metavar x, y, k ::= {{ com Variables }}
metavar op ::= {{ com Operations }}
metavar kappa {{ tex \kappa }} ::= {{ com Base types }}
indexvar i ::=

grammar
M, N, L :: 'M_' ::= {{ com Terms }}
| x :: :: Var {{ com Variable }}
| N M :: :: App {{ com Application }}
| fun x . M :: :: Lam {{ com Abstraction }}
| k :: :: Kon {{ com Constant }}
| M + N :: :: Prim {{ com Primitive function }}
| () :: :: Unit {{ com Unit }}
| cast pp M :: :: Cast {{ com Cast }} {{ tex [[M]] \,\MVAt\, [[pp]] }}
| M Up G :: :: Box {{ com Box }}
| blame :: :: Blame {{ com Blame }}
| op ( M ) :: :: Operation {{ com Operation }}
| handle H M :: :: Handle {{ com Handler }}
| ( M ) :: M :: Parens

H :: 'H_' ::= {{ com Handlers }}
| return x . M ; opclauses :: :: Handler

P, Q :: 'P_' ::= {{ com Computation type }}
| A ! E :: :: Dirt % {{ tex [[A]]\;!\;[[E]] }}

A, B, C :: 'A_' ::= {{ com Value type }}
| star :: :: Any {{ com Dynamic type }}
| A -> P :: :: Arr {{ com Function type }}
| kappa :: :: Kon {{ com Base type }}
| unit :: :: Unit {{ com Unit type }}
| ( A ) :: :: Parens
| G :: M :: Ground

G :: 'G_' ::= {{ com Ground type }}
| star -> star :: :: Arr
| kappa :: :: Kappa
| unit :: :: Unit

E, F :: 'E_' ::= {{ com Effect }}
| wstar :: :: Any {{ com Dynamic effect }}
| ops :: :: Ops {{ com Static effect }} {{ tex \fori{i}{n}{op_i} }}

pp {{ tex {\pm p} }} :: 'pp_' ::= {{ com Polarized computation cast }}
| + p :: :: Plus
| - p :: :: Minus

pa {{ tex {\pm a} }} :: 'pa_' ::= {{ com Polarized value cast }}
| + a :: :: Plus
| - a :: :: Minus

pe {{ tex {\pm e} }} :: 'pe_' ::= {{ com Polarized effect cast }}
| + e :: :: Plus
| - e :: :: Minus

p :: 'p_' ::= {{ com Computation cast }}
| a ! e :: :: Dirt

a :: 'a_' ::= {{ com Value cast }}
| id :: :: Id
| a -> p :: :: Arr

e :: 'e_' ::= {{ com Effect cast }}
| id :: :: Id
| Up E :: :: Up {{ com Downcast ($[[E]] = \fori{i}{n}{op_i}$) }}

Gamma {{ tex \Gamma }} :: 'G_' ::= {{ com Typing contexts }}
| empty :: :: Empty
| Gamma , x : A :: :: Cons

terminals :: 'terminals_' ::=
| fun :: :: lambda {{ tex \lambda }}
| nil :: :: nil {{ tex \cdot }}
| -> :: :: Arrow {{ tex \rightarrow }}
| --> :: :: LongArrow {{ tex \longrightarrow }}
| => :: :: Bigarrow {{ tex \Rightarrow }}
| ~> :: :: Sqgarrow {{ tex \leadsto }}
| |- :: :: Turnstile {{ tex \vdash }}
| |-? :: :: Turnstileq {{ tex \vdash_{?} }}
| |-! :: :: Turnstilee {{ tex \vdash_{!} }}
| |-?! :: :: Turnstilex {{ tex \vdash_{?!} }}
| in :: :: In {{ tex \in }}
| in? :: :: Inq {{ tex \in_{?} }}
| subset :: :: Subset {{ tex \subseteq }}
| subset? :: :: Subsetq {{ tex \subseteq_{?} }}
| Up :: :: Up {{ tex \Uparrow }}
| wstar :: :: WStar {{ tex \mbox{\tiny\FiveStarOpen} }}
| star :: :: Star {{ tex \star }}

formula :: formula_ ::=
| judgement :: :: judgement
| ( formula ) :: M :: brackets
| formula AND formula' :: M :: space {{ tex [[formula]] \quad\quad [[formula']] }}
| x /= y :: :: VarNEq {{ tex [[x]] \neq [[y]] }}
| k \in denote kappa :: :: kon_typing {{ tex [[k]] \in \llbracket [[kappa]] \rrbracket }}
| primtype kappa kappa' kappa'' :: :: primitive_typing {{ tex \mathrm{typeof}(+) = ([[kappa]] \to [[kappa']] \to [[kappa'']]) }}
| sig op A B :: :: SigOp {{ tex \mathrm{sig}([[op]]) = [[A]] \to [[B]] }}

% Nope
% subrules
%   G <:: A

defns
Jtype :: '' ::=

defn
Gamma |- x : A :: ::varhastype:: '' {{ com in context $[[Gamma]]$, $[[x]]$ has type $[[A]]$ }} by

  ----- :: var_here
  Gamma , x : A |- x : A

  x /= y
  ----- :: var_there
  Gamma , y : B |- x : A
  
defn
Gamma |- M : P :: ::hastype:: '' {{ com in context $[[Gamma]]$, $[[M]]$ has type $[[P]]$ }} by

  Gamma |- x : A
  ----- :: type_var
  Gamma |- x : A ! E

  Gamma |- N : (A -> B ! E) ! E
  Gamma |- M : A ! E
  ----- :: type_app
  Gamma |- N M : B ! E

  Gamma , x : A |- M : B ! E
  ----- :: type_abs
  Gamma |- fun x . M : (A -> B ! E) ! F

  k \in denote kappa
  ----- :: type_kon
  Gamma |- k : kappa ! E

  primtype kappa kappa' kappa''
  Gamma |- M : kappa ! E
  Gamma |- N : kappa' ! E
  ----- :: type_prim
  Gamma |- M + N : kappa'' ! E

  ----- :: type_unit
  Gamma |- () : unit ! E

  Gamma |- M : P
  ----- :: type_cast
  Gamma |- cast pp M : Q

  Gamma |- M : G ! E
  ----- :: type_box
  Gamma |- M Up G : star ! E

  ----- :: type_blame
  Gamma |- blame : P

  sig op A B
  op in E
  Gamma |- M : A ! E
  ----- :: type_op
  Gamma |- op ( M ) : B ! E

  Gamma |- H : P => Q
  Gamma |- M : P
  ----- :: type_handle
  Gamma |- handle H M : Q

defn
Gamma |- H : P => Q :: ::hashtype:: '' {{ com in context $[[Gamma]]$, $[[H]]$ has handler type $[[P]] \Rightarrow [[Q]]$ }} by

defn
op in E :: ::opin:: '' {{ com operation $[[op]]$ is a member of effect $[[E]]$ }} by

  ----- :: op_in_star
  op in wstar

  ----- :: op_in_ops
  opi in ops
