metavar x, y, k ::= {{ com Variables }}
metavar op ::= {{ com Operations }}
metavar kappa {{ tex \kappa }} ::= {{ com Base types }}
indexvar i, j ::=

grammar
M, N, L :: 'M_' ::= {{ com Terms }}
| x :: :: Var {{ com Variable }}
| N M :: :: App {{ com Application }}
| fun x . M :: :: Lam {{ com Abstraction }}
| k :: :: Kon {{ com Constant }}
| M + N :: :: Prim {{ com Primitive function }}
| () :: :: Unit {{ com Unit }}
| cast pp M :: :: Cast {{ com Cast }} {{ tex [[M]] \,\MVAt\, [[pp]] }}
| M Up G :: :: Box {{ com Box }}
| blame :: :: Blame {{ com Blame }}
| op ( M ) :: :: Operation {{ com Operation }}
| handle H M :: :: Handle {{ com Handler }}
| ( M ) :: M :: Parens
| N [ M / x ] :: M :: Subst
| Ex [ M ] :: M :: ESubst
| H ** op :: M :: HOpClause {{ tex [[H]]_{[[op]]} }}
| H return :: M :: HReturnClause {{ tex [[H]]^{\mathrm{ret} } }}

V :: V_ ::= {{ com Values }}
| fun x . M :: :: Lam {{ com Abstraction }}
| k :: :: Kon {{ com Constant }}
| V Up G :: :: Box {{ com Box }}

H :: 'H_' ::= {{ com Handlers }}
| return x . M ; opclauses :: :: Handler

P, Q :: 'P_' ::= {{ com Computation type }}
| A ! E :: :: Dirt % {{ tex [[A]]\;!\;[[E]] }}

A, B, C :: 'A_' ::= {{ com Value type }}
| star :: :: Any {{ com Dynamic type }}
| A -> P :: :: Arr {{ com Function type }}
| kappa :: :: Kon {{ com Base type }}
| unit :: :: Unit {{ com Unit type }}
| ( A ) :: S:: Parens
| G :: M :: Ground

G :: 'G_' ::= {{ com Ground type }}
| star -> star :: :: Arr
| kappa :: :: Kappa
| unit :: :: Unit

E, F :: 'E_' ::= {{ com Effect }}
| wstar :: :: Any {{ com Dynamic effect }}
| ops :: :: Ops {{ com Static effect }} {{ tex \fori{i}{n}{op_i} }}

pp {{ tex {\pm p} }} :: 'pp_' ::= {{ com Polarized computation cast }}
| + p :: :: Plus
| - p :: :: Minus
| +- p :: X:: PM
| -+ p :: X:: MP

pa {{ tex {\pm a} }} :: 'pa_' ::= {{ com Polarized value cast }}
| + a :: :: Plus
| - a :: :: Minus
| +- a :: X:: PM
| -+ a :: X:: MP

pe {{ tex {\pm e} }} :: 'pe_' ::= {{ com Polarized effect cast }}
| + e :: :: Plus
| - e :: :: Minus
| +- e :: X:: PM
| -+ e :: X:: MP

p :: 'p_' ::= {{ com Computation cast }}
| a ! e :: :: Dirt
| ( p ) :: X:: Parens

a :: 'a_' ::= {{ com Value cast }}
| id :: :: Id
| a -> p :: :: Arr
| a Up G :: :: Box
| ( a ) :: X:: Parens

e :: 'e_' ::= {{ com Effect cast }}
| id :: :: Id
| Up E :: :: Up {{ com Downcast ($[[E]] = \fori{i}{n}{op_i}$) }}

Gamma {{ tex \Gamma }} :: 'G_' ::= {{ com Typing contexts }}
| empty :: :: Empty
| Gamma , x : A :: :: Cons

Ex {{ tex \mathcal{E} }} :: E_ ::= {{ com Evaluation contexts }}


terminals :: 'terminals_' ::=
| fun :: :: lambda {{ tex \lambda }}
| nil :: :: nil {{ tex \cdot }}
| -> :: :: Arrow {{ tex \rightarrow }}
| --> :: :: LongArrow {{ tex \longrightarrow }}
| => :: :: Bigarrow {{ tex \Rightarrow }}
| ~> :: :: Sqgarrow {{ tex \leadsto }}
| |- :: :: Turnstile {{ tex \vdash }}
| |-? :: :: Turnstileq {{ tex \vdash_{?} }}
| |-! :: :: Turnstilee {{ tex \vdash_{!} }}
| |-?! :: :: Turnstilex {{ tex \vdash_{?!} }}
| in :: :: In {{ tex \in }}
| in? :: :: Inq {{ tex \in_{?} }}
| subset :: :: Subset {{ tex \subseteq }}
| subset? :: :: Subsetq {{ tex \subseteq_{?} }}
| Up :: :: Up {{ tex \Uparrow }}
| wstar :: :: WStar {{ tex \mbox{\tiny\FiveStarOpen} }}
| star :: :: Star {{ tex \star }}
| \le :: :: LessThan {{ tex \le }}
| +- :: :: PlusMinus {{ tex \pm }}
| -+ :: :: MinusPlus {{ tex \mp }}

formula :: formula_ ::=
| judgement :: :: judgement
| ( formula ) :: M :: brackets
| formula AND formula' :: M :: space {{ tex [[formula]] \quad\quad [[formula']] }}
| x /= y :: :: VarNEq {{ tex [[x]] \neq [[y]] }}
| G /= G' :: :: GNEq {{ tex [[G]] \neq [[G']] }}
| k \in denote kappa :: :: kon_typing {{ tex [[k]] \in \llbracket [[kappa]] \rrbracket }}
| primtype kappa kappa' kappa'' :: :: primitive_typing {{ tex \mathrm{typeof}(+) = ([[kappa]] \to [[kappa']] \to [[kappa'']]) }}
| sig op A B :: :: SigOp {{ tex \mathrm{sig}([[op]]) = [[A]] \to [[B]] }}
| k'' is denote k + k' :: :: DenOp {{ tex [[k'']] = \llbracket [[k]] + [[k']] \rrbracket }}
| op is not bound Ex :: :: Unbound_Ex {{ tex [[op]] \not\in \mathrm{bound}([[Ex]]) }}
| op is bound pe :: :: Bound_pe {{ tex [[op]] \in \mathrm{bound}([[pe]]) }}
| op is bound H :: :: Bound_H {{ tex [[op]] \in \mathrm{bound}([[H]]) }}


subrules
  V <:: M
% Nope
%   G <:: A

defns
Jtype :: '' ::=

defn
Gamma |- x : A :: ::varhastype:: '' {{ com in context $[[Gamma]]$, $[[x]]$ has type $[[A]]$ }} by

  ----- :: var_here
  Gamma , x : A |- x : A

  x /= y
  ----- :: var_there
  Gamma , y : B |- x : A
  
defn
Gamma |- M : P :: ::hastype:: '' {{ com in context $[[Gamma]]$, $[[M]]$ has type $[[P]]$ }} by

  Gamma |- x : A
  ----- :: type_var
  Gamma |- x : A ! E

  Gamma |- N : (A -> B ! E) ! E
  Gamma |- M : A ! E
  ----- :: type_app
  Gamma |- N M : B ! E

  Gamma , x : A |- M : B ! E
  ----- :: type_abs
  Gamma |- fun x . M : (A -> B ! E) ! F

  k \in denote kappa
  ----- :: type_kon
  Gamma |- k : kappa ! E

  primtype kappa kappa' kappa''
  Gamma |- M : kappa ! E
  Gamma |- N : kappa' ! E
  ----- :: type_prim
  Gamma |- M + N : kappa'' ! E

  ----- :: type_unit
  Gamma |- () : unit ! E

  Gamma |- M : P
  ----- :: type_cast
  Gamma |- cast pp M : Q

  Gamma |- M : G ! E
  ----- :: type_box
  Gamma |- M Up G : star ! E

  ----- :: type_blame
  Gamma |- blame : P

  sig op A B
  op in E
  Gamma |- M : A ! E
  ----- :: type_op
  Gamma |- op ( M ) : B ! E

  Gamma |- H : P => Q
  Gamma |- M : P
  ----- :: type_handle
  Gamma |- handle H M : Q

defn
Gamma |- H : P => Q :: ::hashtype:: '' {{ com in context $[[Gamma]]$, $[[H]]$ has handler type $[[P]] \Rightarrow [[Q]]$ }} by

defn
pp : P => Q :: ::pphastype:: '' {{ com $[[pp]]$ has type $[[P]] \Rightarrow [[Q]]$ }} by

  p : P \le Q
  ----- :: ptype_plus
  + p : P => Q

  p : Q \le P
  ----- :: ptype_minus
  - p : P => Q

defn
p : P \le P' :: ::phastype:: '' {{ com $[[p]]$ is evidence that $[[P]]$ is more precise than $[[P']]$ }} by

  a : A \le A'
  e : E \le E'
  ----- :: ptype_dirt
  a ! e : A ! E \le A' ! E'

defn
a : A \le A' :: ::ahastype:: '' {{ com $[[a]]$ is evidence that $[[A]]$ is more precise than $[[A']]$ }} by

  ----- :: atype_id
  id : A \le A

  a : A \le A'
  p : P \le P'
  ----- :: atype_arr
  a -> p : A -> P \le A' -> P'

  a : A \le G
  ----- :: atype_box
  a Up G : A \le star

defn
e : E \le E' :: ::ehastype:: '' {{ com $[[e]]$ is evidence that $[[E]]$ is more precise than $[[E']]$ }} by


defn
op in E :: ::opin:: '' {{ com operation $[[op]]$ is a member of effect $[[E]]$ }} by

  ----- :: op_in_star
  op in wstar

  ----- :: op_in_ops
  opi in ops

defns
Jred :: '' ::=

defn
M --> N :: ::red:: '' by

  ----- :: beta
  (fun x . N) V --> N [ V / x ]

  k'' is denote k + k'
  ----- :: delta
  k + k' --> k''

  ----- :: cast_id
  cast +- id ! e V --> V

  ----- :: cast_wrap
  cast +- ( a -> p ) ! e (fun x . M) --> fun x . cast +- p ( M ( cast -+ a ! id x ) )

  ----- :: cast_expand
  cast + (a Up G) ! e V --> ( cast + a ! e V ) Up G

  ----- :: cast_collapse
  cast - (a Up G) ! e (V Up G) --> cast - a ! e V

  G /= G'
  ----- :: cast_collide
  cast - (a Up G) ! e (V Up G') --> blame

  op is not bound Ex
  op is bound +- e
  ----- :: cast_op_blame
  cast +- a ! e Ex [ op ( V ) ] --> blame

  op is not bound Ex
  op is bound H
  ----- :: handle_op
  handle H Ex [ op ( V ) ] --> H ** op [ V / x ] [ (fun y . handle H Ex [ y ]) / k ]

  ----- :: handle_return
  handle H V --> H return [ V / x ]

defn
gamma |- M <= M' : p :: ::prec:: '' {{ com $[[M]]$ is more precise than $[[M']]$ with type-precision $[[p]]$ }} by

  gamma |- x : a
  ----- :: prec_var
  gamma |- x <= x : a ! e

defn
gamma |- x : a :: ::varprec:: '' by
