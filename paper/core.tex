\section{Gradual Eff}

\newcommand\ruledef{::=}
\newcommand\rulealt{\;|\;}
\newcommand\tyarr[2]{#1 \to #2}
\newcommand\tyany{\star}
\newcommand\cty[2]{#2 ! #1}
\newcommand\tynat{\mathrm{nat}}
\newcommand\tybool{\mathrm{bool}}
\newcommand\tyunit{\mathrm{unit}}
\newcommand\effany{\mbox{\tiny\FiveStarOpen}}
\newcommand\effop{\mathit{op}}
\newcommand\app[2]{#1\,#2}
\newcommand\lam[2]{\lambda\, #1 .\, #2}
\newcommand\cast[2]{#1 \,\MVAt\, #2}
\newcommand\tbox[2]{#1 \Uparrow #2}
\newcommand\blame{\mathrm{blame}}
\newcommand\perform[2]{#1\left(#2\right)}
\newcommand\handle[2]{\mathbf{handle}\,\{#1\}\,#2}
\newcommand\fori[3]{(#3)_{#1=1\dots #2}}
\newcommand\foriset[3]{\{#3\}_{#1=1\dots #2}}
\newcommand\treturn[1]{\mathbf{return}\,#1}
\newcommand\stepto{\rightsquigarrow}
\newcommand\stepsto{\stepto^\ast}
\newcommand\subst[3]{#1[#2/#3]}
\newcommand\context[2]{#1[#2]}
\newcommand\xC{\mathcal{C}}
\newcommand\xE{\mathcal{E}}
\newcommand\xP{\mathcal{P}}
\newcommand\bound[1]{\mathbf{bound}(#1)}
\newcommand\cid{\mathrm{id}}
\newcommand\commutel[3]{\mathbf{commutes}^l(#1,#2,#3)}
\newcommand\commuter[3]{\mathbf{commutes}^r(#1,#2,#3)}
\newcommand\cod[1]{\mathrm{cod}(#1)}
\newcommand\codeff[1]{\mathrm{eff}(#1)}
\newcommand\dom[1]{\mathrm{dom}(#1)}
\newcommand\typeof[1]{\mathrm{typeof}(#1)}
\newcommand\dprime{{\prime\prime}}

\newcommand\Term[3]{#1 \vdash #2 : #3}
\newcommand\TermP[4]{#1 \vdash #2 \le #3 : #4}

\GEall

\section{Cast calculus with handlers}

Syntax and operational semantics.

Our effect system is based on Eff~\cite{bauer2015programming}.

\subsection{Types}

We distinguish two kinds of types: value types $A$, $B$ (base types, function type, and
dynamic type $\star$) and computation types $P$, $Q$ which pair a value type with an effect (also called \emph{dirt}).

Effects may be static or dynamic. A static effect is a list of operation names,
restricting the operations that a computation may perform. The dynamic effect $\effany$
allows any operation to be performed.

\paragraph{Precision}
In a gradually typed language, types are intuitively ordered by the amount of
static information they give about their inhabitants. This ordering is called
naive subtyping, or \emph{precision}.
We write $a : A \le A'$ to mean that $a$ is a proof that $A$ is more precise than $A'$.
The least precise type is $\star$.
Effects are also ordered by precision, with the least precise effect being $\effany$.
A static effect is only related to itself and to $\effany$.
Effect subtyping can be added as an orthogonal feature.

A proof of precision $a : A \le A'$ serves as a cast between $A$ and $A'$:
either an upcast $+a : A \Rightarrow A'$ or a downcast $-a : A' \Rightarrow A$.

We chose to have a reflexivity rule for all types. Another design choice would
be to only introduce that rule for base types, which would make proofs of precision
$a : A \le A'$ unique for a given $A$ and $A'$.
It is more efficient to have an identity cast.

\subsection{Terms}

Unlike Eff, we do not define fine-grained call-by-value calculus, as that leads
to complications when treating function casts in the proof of the gradual guarantee.

Thus, all terms are treated as computations, and are given computation types
in the judgement $\Gamma \vdash M : P$.
In particular, function applications $N\;M$ and operator applications $M + N$
sequence the computations for their operands, so they must all have the same
effect $E$.

Performing an operation $\mathbf{op}(M)$ requires $\mathbf{op}$ to be allowed
by the effect $E$: either $E$ is a static effect, then $\mathbf{op}$ must occur
in it, or $E$ is a dynamic effect, which allows all operations.

$\mathbf{handle}\,H\,M$ is a handler $H$ applied to a computation $M$.
A handler $H$ consists of one return clause which expects the result of the
handled computation, and zero or more operation clauses.

There are two kinds of casts: value casts and effect casts, respectively
changing the value type and the effect of a term.

A box is a value of the dynamic type. It contains a ground type $G$
(which correspond to a type constructor) and a value of that type.
To cast a function from a non-ground type, $A \to P$ to $\star$,
we will first cast $A \to P$ to the ground type
$\star \to \star\,!\,\effany$ (by casting the domain and codomain individually),
which can then be boxed.

The $\mathbf{blame}$ constructor indicates a type error at run time.

\subsection{Operational semantics}

The behavior of casts depends on the structure of the cast.
A function cast $\pm (a \to b ! e)$
is split into casts on its domain, codomain, and effect, $\mp a$ (note the inverted polarity), $\pm b$, $\pm e$,
and the cast function is wrapped in a new function which applies those casts on
the input and output of the wrapped function.
An upcast into the dynamic type, $+ (a \Uparrow G)$
recursively applies the cast $+ a$ into $G$, and then put the
result in a box $V \Uparrow G$.
A downcast from the dynamic type, $- (a \Uparrow G)$ compares
the tag $G$ with the tag in the box $V \Uparrow G'$. The value is unboxed
if the tags are equal, otherwise we raise $\mathbf{blame}$.

The semantics of handlers is standard. A handler handles operations under an
evaluation context. The closest matching handler is selected by ensuring that
the evaluation context cannot already handle the operation.
Operations may be handled not only by handlers, but also by effect casts.



\begin{figure}
\[
\begin{array}{rcl}
\multicolumn{3}{l}{\fbox{$\bound{\xC}$}} \\
  \bound{\square} & = & \emptyset \\
  \bound{\context{\xP}{\xC}} & = & \bound{\xC} \\
  \bound{\handle{H}{\xC}} & = & \bound{H} \cup \bound{\xC} \\
  \bound{\cast{\xC}{\pm \cty{e}{a}}} & = & \bound{e} \cup \bound{\xC} \\
\multicolumn{3}{l}{\fbox{$\bound{e}$}} \\
  \bound{\pm\, \cid} & = & \emptyset \\
  \bound{+ \Uparrow E} & = & \emptyset \\
  \bound{- \Uparrow E} & = & \mathbf{Op} - E \\
  && \quad \makebox[0pt]{\text{where $\mathbf{Op}$ is the set of all operation symbols} }
\end{array}
\]
\[
\begin{array}{rcl}
\multicolumn{3}{l}{\fbox{$\bound{H}$}} \\
  \bound{\treturn{x}\mapsto N, \fori{i}{n}{\perform{\effop_i}{x,k} \mapsto N_i}}
    &=& \foriset{i}{n}{\effop_i}
\end{array}
\]
\caption{Operations bound by evaluation contexts and by effect casts}
\end{figure}

\section{Gradual guarantee}

If a term $M^\prime$ is less precise than $M$ and $M$ evaluates to $V$,
then $M^\prime$ evaluates to some $V^\prime$ less precise than $V$.

\newcommand\wwedge{\quad\wedge\quad}

\[
\begin{array}{rrcl}
  & \TermP{}{M}{M^\prime}{p} & \wedge & M \stepsto V
\\ \implies \exists V^\prime , & \TermP{}{V}{V^\prime}{p} & \wedge & M^\prime \stepsto V^\prime
\end{array}
\]

Simulation lemma (\Cref{fig:sim}): If $M^\prime$ is less precise than $M$, and $M$ takes one step to $N$,
then $M^\prime$ steps (in possibly many steps) to some $N^\prime$ less precise than $N$.

\[
\begin{array}{rrcl}
  & \TermP{}{M}{M^\prime}{p} & \wedge & M \stepto N
\\ \implies \exists N^\prime , & \TermP{}{N}{N^\prime}{p} & \wedge & M^\prime \stepsto N^\prime
\end{array}
\]

Catchup lemma (\Cref{fig:catchup}): if $M^\prime$ is less precise than a value $V$, then $M^\prime$ steps
to a value $V^\prime$ less precise than $V$.

\[
\begin{array}{rrcl}
  & \TermP{}{V}{M^\prime}{p} & &
\\ \implies \exists V^\prime , & \TermP{}{V}{V^\prime}{p} & \wedge & M^\prime \stepsto V^\prime
\end{array}
\]

\begin{figure}
$$
\input{figures/sim}
$$
\caption{Diagram illustrating the simulation lemma}
\label{fig:sim}
\end{figure}

\begin{figure}
$$ \input{figures/catchup} $$
\caption{Diagram illustrating the catchup lemma}
\label{fig:catchup}
\end{figure}
