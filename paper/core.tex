\section{Gradual Eff}

\newcommand\ruledef{::=}
\newcommand\rulealt{\;|\;}
\newcommand\tyarr[2]{#1 \to #2}
\newcommand\tyany{\star}
\newcommand\cty[2]{#2 ! #1}
\newcommand\tynat{\mathrm{nat}}
\newcommand\tybool{\mathrm{bool}}
\newcommand\tyunit{\mathrm{unit}}
\newcommand\effany{\mbox{\tiny\FiveStarOpen}}
\newcommand\effop{\mathit{op}}
\newcommand\app[2]{#1\,#2}
\newcommand\lam[2]{\lambda\, #1 .\, #2}
\newcommand\cast[2]{#1 \,\MVAt\, #2}
\newcommand\tbox[2]{#1 \Uparrow #2}
\newcommand\blame{\mathrm{blame}}
\newcommand\perform[2]{#1\left(#2\right)}
\newcommand\handle[2]{\mathbf{handle}\,#2\,\{#1\}}
\newcommand\fori[3]{(#3)_{#1=1\dots #2}}
\newcommand\treturn[1]{\mathbf{return}\,#1}
\newcommand\bstepto{\to_\mathbf{base}}
\newcommand\stepto{\to}
\newcommand\stepsto{\to^\ast}
\newcommand\subst[3]{#1[#2/#3]}
\newcommand\context[2]{#1[#2]}
\newcommand\xC{\mathcal{C}}
\newcommand\xE{\mathcal{E}}
\newcommand\xP{\mathcal{P}}
\newcommand\stepperform{\hookrightarrow}
\newcommand\codom[1]{\mathrm{codom}(#1)}
\newcommand\effid{\mathrm{id}}
\newcommand\commutel[3]{\mathrm{commute}^l(#1,#2,#3)}
\newcommand\commuter[3]{\mathrm{commute}^r(#1,#2,#3)}

\newcommand\Term[3]{#1 \vdash #2 : #3}
\newcommand\TermP[6]{#1 \vdash #2 \le #4 : #3 \le #5 \;|\; #6}

\begin{figure}
$$
\begin{array}{rrcll}
 \text{Base types} & \kappa  & \ruledef & \tynat \rulealt \tybool \\
 \text{Value types} & A, B, C & \ruledef & \kappa \rulealt \tyunit \rulealt \tyarr{A}{P} \rulealt \tyany & \\
 \text{Computation types} & P, Q, R & \ruledef & \cty{E}{A} &  \\
 \text{Effects} & E, F & \ruledef & \fori{i}{n}{\effop_i} \rulealt \effany & \\
 \text{Ground types} & G, H & \ruledef & \tynat \rulealt \tybool \rulealt \tyunit \rulealt \tyarr{\tyany}{\tyany}
\end{array}
$$
\caption{Types}
\label{fig:types}
\end{figure}

\begin{figure}
$$
\begin{array}{rrcll}
 \text{Terms} &
 L, M, N & \ruledef & x & \text{Variable} \\
        && \rulealt & \lam{x}{M} & \text{Abstraction} \\
        && \rulealt & \app{L}{M} & \text{Application} \\
        && \rulealt & k & \text{Constant} \\
        && \rulealt & M \oplus N & \text{Operator} \\
        && \rulealt & () & \text{Unit} \\
        && \rulealt & \cast{M}{{\pm p}} & \text{Cast} \\
        && \rulealt & \tbox{M}{G} & \text{Box} \\
        && \rulealt & \blame & \text{Blame} \\
        && \rulealt & \perform{\effop}{M} & \text{Operation} \\
        && \rulealt & \handle{H}{M} & \text{Handler} \\
 \text{Handlers} &
 H & \ruledef & \treturn{x} \mapsto L, \fori{i}{n}{\perform{\effop_i}{x} k \mapsto N_i} &
\end{array}
$$
\caption{Term syntax}
\label{fig:term-syntax}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$\Term{\Gamma}{M}{P}$}
    \AxiomC{$\pm p : P \Rightarrow Q$}
    \RightLabel{\textsc{Cast}}
  \BinaryInfC{$\Term{\Gamma}{\cast{M}{\pm p}}{Q}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Term{\Gamma}{M}{\cty{E}{G}}$}
    \RightLabel{\textsc{Box}}
  \UnaryInfC{$\Term{\Gamma}{\tbox{M}{G}}{\cty{E}{\tyany}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Sigma(\effop) = A \to B \quad\quad \effop \in E$}
    \AxiomC{$\Term{\Gamma}{M}{\cty{E}{A}}$}
    \RightLabel{\textsc{Op}}
  \BinaryInfC{$\Term{\Gamma}{\perform{\effop}{M}}{\cty{E}{B}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\begin{array}{c}E = \fori{i}{n}{\effop_i},F \\ \Term{\Gamma,x:A}{L}{\cty{F}{B}}\end{array}$}
    \AxiomC{$\begin{array}{c}\fori{i}{n}{\Sigma(\effop_i) = A_i \to B_i} \\ \fori{i}{n}{\Term{\Gamma,x:A_i,k:\tyarr{B_i}{\cty{F}{B}}}{N_i}{\cty{F}{B}}}\end{array}$}
    \AxiomC{$\Term{\Gamma}{M}{\cty{E}{A}}$}
    \RightLabel{\textsc{Handle}}
  \TrinaryInfC{$\Term{\Gamma}{\handle{\treturn{x} \mapsto L, \fori{i}{n}{\perform{\effop_i}{x,k} \mapsto N_i}}{M}}{\cty{F}{B}}$}
\end{prooftree}
\caption{Term typing}
\label{fig:term-typing}
\end{figure}

\begin{figure}
$$
\begin{array}{rrcll}
 \text{Casts} & a, b, c & \ruledef & \kappa \rulealt \tyunit \rulealt \tyany \rulealt \tyarr{a}{p} \rulealt a \Uparrow G & \\
 \text{Computation casts} & p, q, r & \ruledef & \cty{e}{a} & \\
 \text{Effect casts} & e & \ruledef & \effid_E \rulealt \Uparrow \fori{i}{n}{\effop_i} & \\
 \text{Polarized casts} & {\pm p} & \ruledef & {}+ p \rulealt {}- p &
\end{array}
$$
\caption{Cast syntax}
\label{fig:cast-syntax}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\kappa : \kappa \le \kappa$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\tyunit : \tyunit \le \tyunit$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\tyany : \tyany \le \tyany$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$a : A \le A^\prime$}
    \AxiomC{$p : P \le P^\prime$}
  \BinaryInfC{$\tyarr{a}{p} : \tyarr{A}{P} \le \tyarr{A^\prime}{P^\prime}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$a : A \le G$}
  \UnaryInfC{$a\Uparrow G : A \le \tyany$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$e : E \le E^\prime$}
    \AxiomC{$a : A \le A^\prime$}
  \BinaryInfC{$\cty{e}{a} : \cty{E}{A} \le \cty{E^\prime}{A^\prime}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\effid_E : E \le E$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\Uparrow (\effop_i)_{i=1\dots n} : (\effop_i)_{i=1\dots n} \le \effany$}
\end{prooftree}
\caption{Cast typing $a : A \le A^\prime$, $p : P \le P^\prime$, $e : E \le E^\prime$}
\label{fig:cast-typing}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$p : A \le B$}
  \UnaryInfC{$+p : A \Rightarrow B$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$p : B \le A$}
  \UnaryInfC{$-p : A \Rightarrow B$}
\end{prooftree}
\caption{Polarised cast typing $\pm p : A \Rightarrow B$}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$M \bstepto N$}
  \UnaryInfC{$\context{\xC}{M} \stepto \context{\xC}{N}$}
\end{prooftree}
\caption{Small-step operational semantics}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{$\beta$-\textsc{Red}}
  \UnaryInfC{$\app{(\lam{x}{N})}{V} \bstepto \subst{N}{V}{x}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$a \in \{\kappa,\tyunit,\tyany\}$}
    \RightLabel{\textsc{CastId-Red}}
  \UnaryInfC{$\cast{V}{\pm \cty{e}{a}} \bstepto V$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{CastWrap-Red}}
  \UnaryInfC{$\cast{V}{\pm\cty{e}{(\tyarr{a}{p})}} \bstepto (\lam{x}{\cast{(\app{V}{(\cast{x}{\mp \cty{\effid_E}{a}})})}{\pm p}})$}
\end{prooftree}
TODO: need to know the type of $V$ to find $E$
\begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{CastExpand-Red}}
  \UnaryInfC{$(\cast{V}{+\cty{e}{(a \Uparrow G)}}) \bstepto (\cast{V}{+\cty{e}{a}}) \Uparrow G$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{CastCollapse-Red}}
  \UnaryInfC{$(\cast{(V \Uparrow G)}{-\cty{e}{(a \Uparrow G)}}) \bstepto (\cast{V}{-\cty{e}{a}})$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$G \neq H$}
    \RightLabel{\textsc{CastCollide-Red}}
  \UnaryInfC{$(\cast{(V \Uparrow G)}{-\cty{e}{(a \Uparrow H)}}) \bstepto \blame$}
\end{prooftree}
\caption{Operational semantics: base reduction}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V , \xC}$}
    \AxiomC{$\effop \not\in \pm e$}
    \RightLabel{\textsc{EffCast-Red}}
  \BinaryInfC{$(\cast{M}{\pm\cty{e}{a}}) \bstepto \blame$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop_j}{V , \xC}$}
    \AxiomC{$H = x \mapsto N, \fori{i}{n}{\perform{\effop_i}{x, k} \mapsto N_i}$}
    \RightLabel{\textsc{HandleOp-Red}}
  \BinaryInfC{$\handle{H}{M} \bstepto \subst{\subst{N_j}{V}{x}}{(\lam{y}{\handle{H}{\context{\xC}{y}}})}{k}]$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$H = \fori{i}{n}{x \mapsto N, \perform{\effop_i}{x, k} \mapsto N_i}$}
    \RightLabel{\textsc{HandleReturn-Red}}
  \UnaryInfC{$\handle{H}{V} \bstepto \subst{N}{V}{x}$}
\end{prooftree}
\caption{Operational semantics: base reduction rules pertaining to effects}
\end{figure}

\begin{figure}
\[
\begin{array}{rrcl}
 \text{Pure frames} & \xP  & \ruledef & \app{\square}{M} \rulealt \app{V}{\square} \rulealt \perform{\effop}{\square} \rulealt \dots \\
 \text{Computation frames} & \xE & \ruledef & \handle{H}{\square} \rulealt \cast{\square}{\pm p} \\
 \text{Evaluation contexts} & \xC & \ruledef & \square \rulealt \xP[\xC] \rulealt \xE[\xC]
\end{array}
\]
\caption{Evaluation contexts}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\perform{\effop}{V} \stepperform \perform{\effop}{V, \square}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V, \xC}$}
    \AxiomC{$H = x \mapsto N, \fori{i}{n}{\perform{\effop_i}{x, k} \mapsto N_i}$}
    \AxiomC{$\forall i, \effop \neq \effop_i$}
  \TrinaryInfC{$\handle{H}{M} \stepperform \perform{\effop}{V, \handle{H}{\xC}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V, \xC}$}
    \AxiomC{$\effop \in \codom{\pm e}$}
  \BinaryInfC{$\cast{M}{\pm \cty{e}{a}} \stepperform \perform{\effop}{V, \cast{\xC}{\pm \cty{e}{a}}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V, \xC}$}
  \UnaryInfC{$\xP[M] \stepperform \perform{\effop}{V, \xP[\xC]}$}
\end{prooftree}
\caption{Relation $M \stepperform \perform{\effop}{V, \xC}$: $M$ performs $\effop(V)$ in context $\xC$}
\end{figure}

\begin{figure}
\[
\begin{array}{rcl}
  \codom{\pm \effid_E} & = & E \\
  \codom{+ \Uparrow \fori{i}{n}{\effop_i}} & = & \effany \\
  \codom{- \Uparrow \fori{i}{n}{\effop_i}} & = & \fori{i}{n}{\effop_i}
\end{array}
\]
\caption{Codomain of a cast $\pm e$, used in the definition of $\stepperform$}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$\TermP{\Gamma}{M}{P}{M^\prime}{Q^\prime}{r}$}
    \AxiomC{$\commutel{\pm p}{q}{r}$}
  \BinaryInfC{$\TermP{\Gamma}{\cast{M}{\pm p}}{Q}{M^\prime}{Q^\prime}{q}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\TermP{\Gamma}{M}{P}{M^\prime}{Q^\prime}{r}$}
    \AxiomC{$\commuter{p}{\pm q}{r}$}
  \BinaryInfC{$\TermP{\Gamma}{M}{P}{\cast{M^\prime}{\pm q}}{P^\prime}{p}$}
\end{prooftree}
\caption{Term precision $\TermP{\Gamma}{M}{P}{M^\prime}{P^\prime}{p}$}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$p \cdot q = r$}
  \UnaryInfC{$\commutel{+p}{q}{r}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$q = p \cdot r$}
  \UnaryInfC{$\commutel{-p}{q}{r}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$p \cdot q = r$}
  \UnaryInfC{$\commuter{p}{+q}{r}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$p = r \cdot q$}
  \UnaryInfC{$\commuter{p}{-q}{r}$}
\end{prooftree}
\caption{Commutativity conditions}
\end{figure}

\clearpage

\section{Gradual guarantee}

If a term $M^\prime$ is less precise than $M$ and $M$ evaluates to $V$,
then $M^\prime$ evaluates to some $V^\prime$ less precise than $V$.

\newcommand\wwedge{\quad\wedge\quad}

\[
\begin{array}{rrcl}
  & \TermP{}{M}{P}{M^\prime}{P^\prime}{p} & \wedge & M \stepsto V
\\ \implies \exists V^\prime , & \TermP{}{V}{P}{V^\prime}{P^\prime}{p} & \wedge & M^\prime \stepsto V^\prime
\end{array}
\]

Simulation lemma (\Cref{fig:sim}): If $M^\prime$ is less precise than $M$, and $M$ takes one step to $N$,
then $M^\prime$ steps (in possibly many steps) to some $N^\prime$ less precise than $N$.

\[
\begin{array}{rrcl}
  & \TermP{}{M}{P}{M^\prime}{P^\prime}{p} & \wedge & M \stepto N
\\ \implies \exists N^\prime , & \TermP{}{N}{P}{N^\prime}{P^\prime}{p} & \wedge & M^\prime \stepsto N^\prime
\end{array}
\]

Catchup lemma (\Cref{fig:catchup}): if $M^\prime$ is less precise than a value $V$, then $M^\prime$ steps
to a value $V^\prime$ less precise than $V$.

\[
\begin{array}{rrcl}
  & \TermP{}{V}{P}{M^\prime}{P^\prime}{p} & &
\\ \implies \exists V^\prime , & \TermP{}{V}{P}{V^\prime}{P^\prime}{p} & \wedge & M^\prime \stepsto V^\prime
\end{array}
\]

\begin{figure}
$$
\input{figures/sim}
$$
\caption{Diagram illustrating the simulation lemma}
\label{fig:sim}
\end{figure}

\begin{figure}
$$ \input{figures/catchup} $$
\caption{Diagram illustrating the catchup lemma}
\label{fig:catchup}
\end{figure}
