\section{Gradual Eff}

\newcommand\ruledef{::=}
\newcommand\rulealt{\;|\;}
\newcommand\tyarr[2]{#1 \to #2}
\newcommand\tyany{\star}
\newcommand\cty[2]{#2 ! #1}
\newcommand\tynat{\mathrm{nat}}
\newcommand\tybool{\mathrm{bool}}
\newcommand\tyunit{\mathrm{unit}}
\newcommand\effany{\mbox{\tiny\FiveStarOpen}}
\newcommand\effop{\mathit{op}}
\newcommand\app[2]{#1\,#2}
\newcommand\lam[2]{\lambda\, #1 .\, #2}
\newcommand\cast[2]{#1 \,\MVAt\, #2}
\newcommand\tbox[2]{#1 \Uparrow #2}
\newcommand\blame{\mathrm{blame}}
\newcommand\perform[2]{#1\left(#2\right)}
\newcommand\handle[2]{\mathbf{with}\,#1\,\mathbf{handle}\,#2}
\newcommand\fori[3]{(#3)_{#1=1\dots #2}}
\newcommand\treturn[1]{\mathbf{return}\,#1}
\newcommand\stepto{\to_\mathbf{red}}
\newcommand\subst[3]{#1[#2/#3]}
\newcommand\context[2]{#1[#2]}
\newcommand\xC{\mathcal{C}}
\newcommand\xE{\mathcal{E}}
\newcommand\xP{\mathcal{P}}
\newcommand\stepperform{\hookrightarrow}
\newcommand\allows[2]{\mathrm{allows}(#1,#2)}

\begin{figure}
$$
\begin{array}{rrcll}
 \text{Base types} & \kappa  & \ruledef & \tynat \rulealt \tybool \\
 \text{Value types} & A, B, C & \ruledef & \kappa \rulealt \tyunit \rulealt \tyarr{A}{P} \rulealt \tyany & \\
 \text{Computation types} & P, Q, R & \ruledef & \cty{E}{A} &  \\
 \text{Effects} & E, F & \ruledef & \fori{i}{n}{\effop_i} \rulealt \effany & \\
 \text{Ground types} & G, H & \ruledef & \tynat \rulealt \tybool \rulealt \tyunit \rulealt \tyarr{\tyany}{\tyany}
\end{array}
$$
\caption{Types}
\label{fig:types}
\end{figure}

\begin{figure}
$$
\begin{array}{rrcll}
 Terms &
 L, M, N & \ruledef & x & \text{Variable} \\
         & \rulealt & \lam{x}{M} & \text{Abstraction} \\
         & \rulealt & \app{L}{M} & \text{Application} \\
         & \rulealt & k & \text{Constant} \\
         & \rulealt & M \oplus N & \text{Operator} \\
         & \rulealt & () & \text{Unit} \\
         & \rulealt & \cast{M}{{\pm p}} & \text{Cast} \\
         & \rulealt & \tbox{M}{G} & \text{Box} \\
         & \rulealt & \blame & \text{Blame} \\
         & \rulealt & \perform{\effop}{M} & \text{Operation} \\
         & \rulealt & \handle{H}{M} & \text{Handler} \\
 Handlers &
 H & \ruledef & x \mapsto L, \fori{i}{n}{\perform{\effop_i}{x} k \mapsto N_i} &
\end{array}
$$
\caption{Term syntax}
\label{fig:term-syntax}
\end{figure}

\newcommand\Term[3]{#1 \vdash #2 : #3}

\begin{figure}
\begin{prooftree}
    \AxiomC{$\Term{\Gamma}{M}{P}$}
    \AxiomC{$\pm p : P \Rightarrow Q$}
    \RightLabel{\textsc{Cast}}
  \BinaryInfC{$\Term{\Gamma}{\cast{M}{\pm p}}{Q}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Term{\Gamma}{M}{\cty{E}{G}}$}
    \RightLabel{\textsc{Box}}
  \UnaryInfC{$\Term{\Gamma}{\tbox{M}{G}}{\cty{E}{\tyany}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\Sigma(\effop) = A \to B \quad\quad \effop \in E$}
    \AxiomC{$\Term{\Gamma}{M}{\cty{E}{A}}$}
    \RightLabel{\textsc{Op}}
  \BinaryInfC{$\Term{\Gamma}{\perform{\effop}{M}}{\cty{E}{B}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$\begin{array}{c}E = \fori{i}{n}{\effop_i},F \\ \Term{\Gamma,x:A}{L}{\cty{F}{B}}\end{array}$}
    \AxiomC{$\begin{array}{c}\fori{i}{n}{\Sigma(\effop_i) = A_i \to B_i} \\ \fori{i}{n}{\Term{\Gamma,x:A_i,k:\tyarr{B_i}{\cty{F}{B}}}{N_i}{\cty{F}{B}}}\end{array}$}
    \AxiomC{$\Term{\Gamma}{M}{\cty{E}{A}}$}
    \RightLabel{\textsc{Handle}}
  \TrinaryInfC{$\Term{\Gamma}{\handle{\treturn{x} \mapsto L, \fori{i}{n}{\perform{\effop_i}{x,k} \mapsto N_i}}{M}}{\cty{F}{B}}$}
\end{prooftree}
\caption{Term typing}
\label{fig:term-typing}
\end{figure}

\begin{figure}
$$
\begin{array}{rrcll}
 \text{Casts} & a, b, c & \ruledef & \kappa \rulealt \tyunit \rulealt \rulealt \tyany \tyarr{a}{p} \rulealt a \Uparrow G & \\
 \text{Computation casts} & p, q, r & \ruledef & \cty{e}{a} & \\
 \text{Effect casts} & e & \ruledef & E \rulealt \Uparrow \fori{i}{n}{\effop_i} & \\
 \text{Polarized casts} & {\pm p} & \ruledef & + p \rulealt - p &
\end{array}
$$
TODO: This is the wrong minus sign
\caption{Cast syntax}
\label{fig:cast-syntax}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\kappa : \kappa \le \kappa$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\tyunit : \tyunit \le \tyunit$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\tyany : \tyany \le \tyany$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$a : A \le A^\prime$}
    \AxiomC{$p : P \le P^\prime$}
  \BinaryInfC{$\tyarr{a}{p} : \tyarr{A}{P} \le \tyarr{A^\prime}{P^\prime}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$a : A \le G$}
  \UnaryInfC{$a\Uparrow G : A \le \tyany$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$e : E \le E^\prime$}
    \AxiomC{$a : A \le A^\prime$}
  \BinaryInfC{$\cty{e}{a} : \cty{E}{A} \le \cty{E^\prime}{A^\prime}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$E : E \le E$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\Uparrow (\effop_i)_{i=1\dots n} : (\effop_i)_{i=1\dots n} \le \effany$}
\end{prooftree}
\caption{Cast typing $a : A \le A^\prime$, $p : P \le P^\prime$, $e : E \le E^\prime$}
\label{fig:cast-typing}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$p : A \le B$}
  \UnaryInfC{$+p : A \Rightarrow B$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$p : B \le A$}
  \UnaryInfC{$-p : A \Rightarrow B$}
\end{prooftree}
\caption{Polarised cast typing $\pm p : A \Rightarrow B$}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{$\beta$-\textsc{Red}}
  \UnaryInfC{$\app{(\lam{x}{N})}{V} \stepto \subst{N}{V}{x}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$a \in \{\kappa,\tyunit,\tyany\}$}
    \RightLabel{\textsc{CastId-Red}}
  \UnaryInfC{$\cast{V}{\pm \cty{e}{a}} \stepto V$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{CastWrap-Red}}
  \UnaryInfC{$\cast{V}{\pm\cty{e}{(\tyarr{a}{p})}} \stepto (\lam{x}{\cast{(\app{V}{(\cast{x}{\mp \cty{\mathrm{id}}{a}})})}{\pm p}})$}
\end{prooftree}
TODO: {Need to construct id cast for every effect}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{CastExpand-Red}}
  \UnaryInfC{$(\cast{V}{+\cty{e}{(a \Uparrow G)}}) \stepto (\cast{V}{+\cty{e}{a}}) \Uparrow G$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
    \RightLabel{\textsc{CastCollapse-Red}}
  \UnaryInfC{$(\cast{(V \Uparrow G)}{-\cty{e}{(a \Uparrow G)}}) \stepto (\cast{V}{-\cty{e}{a}})$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$G \neq H$}
    \RightLabel{\textsc{CastCollide-Red}}
  \UnaryInfC{$(\cast{(V \Uparrow G)}{-\cty{e}{(a \Uparrow H)}}) \stepto \blame$}
\end{prooftree}
\caption{Operational semantics}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V , \xC}$}
    \AxiomC{$\effop \not\in \pm e$}
    \RightLabel{\textsc{EffCast-Red}}
  \BinaryInfC{$(\cast{M}{\pm\cty{e}{a}}) \stepto \blame$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop_j}{V , \xC}$}
    \AxiomC{$H = x \mapsto N, \fori{i}{n}{\perform{\effop_i}{x, k} \mapsto N_i}$}
    \RightLabel{\textsc{HandleOp-Red}}
  \BinaryInfC{$\handle{H}{M} \stepto \subst{\subst{N_j}{V}{x}}{(\lam{y}{\handle{H}{\context{\xC}{y}}})}{k}]$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$H = \fori{i}{n}{x \mapsto N, \perform{\effop_i}{x, k} \mapsto N_i}$}
    \RightLabel{\textsc{HandleReturn-Red}}
  \UnaryInfC{$\handle{H}{V} \stepto \subst{N}{V}{x}$}
\end{prooftree}
\caption{Operational semantics, rules pertaining to effects}
\end{figure}

\begin{figure}
\[
\begin{array}{rrcl}
 \text{Pure frames} & \xP  & \ruledef & \app{\square}{M} \rulealt \app{V}{\square} \rulealt \perform{\effop}{\square} \rulealt \dots \\
 \text{Computation frames} & \xE & \ruledef & \handle{H}{\square} \rulealt \cast{\square}{\pm p} \\
 \text{Evaluation contexts} & \xC & \ruledef & \square \rulealt \xP[\xC] \rulealt \xE[\xC]
\end{array}
\]
\caption{Evaluation contexts}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\perform{\effop}{V} \stepperform \perform{\effop}{V, \square}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V, \xC}$}
    \AxiomC{$H = x \mapsto N, \fori{i}{n}{\perform{\effop_i}{x, k} \mapsto N_i}$}
    \AxiomC{$\forall i, \effop \neq \effop_i$}
  \TrinaryInfC{$\handle{H}{M} \stepperform \perform{\effop}{V, \handle{H}{\xC}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V, \xC}$}
    \AxiomC{$\allows{\pm e}{\effop}$}
  \BinaryInfC{$\cast{M}{\pm \cty{e}{a}} \stepperform \perform{\effop}{V, \cast{\xC}{\pm \cty{e}{a}}}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{$M \stepperform \perform{\effop}{V, \xC}$}
  \UnaryInfC{$\xP[M] \stepperform \perform{\effop}{V, \xP[\xC]}$}
\end{prooftree}
\caption{Relation $M \stepperform \perform{\effop}{V, \xC}$: $M$ performs $\effop(V)$ in context $\xC$}
\end{figure}

\begin{figure}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\allows{+ \effany}{\effop}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{}
  \UnaryInfC{$\allows{+ \Uparrow \fori{i}{n}{\effop_i}}{\effop}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{1 \le j \le n}
  \UnaryInfC{$\allows{\pm \fori{i}{n}{\effop_i}}{\effop_j}$}
\end{prooftree}
\begin{prooftree}
    \AxiomC{1 \le j \le n}
  \UnaryInfC{$\allows{- \Uparrow \fori{i}{n}{\effop_i}}{\effop_j}$}
\end{prooftree}
\caption{Operations $\effop$ allowed by a cast $\pm e$}
\end{figure}
