\newcommand\ruledef{::=}
\newcommand\rulealt{\;|\;}
\newcommand\tyarr[2]{#1 \to #2}
\newcommand\tyany{\star}
\newcommand\cty[2]{#2 ! #1}
\newcommand\tynat{\mathrm{nat}}
\newcommand\tybool{\mathrm{bool}}
\newcommand\tyunit{\mathrm{unit}}
\newcommand\tystring{\mathrm{string}}
\newcommand\effany{\mbox{\tiny\FiveStarOpen}}
\newcommand\effop{\mathit{op}}
\newcommand\app[2]{#1\,#2}
\newcommand\lam[2]{\lambda\, #1 .\, #2}
\newcommand\cast[2]{#1 \,\MVAt\, #2}
\newcommand\tbox[2]{#1 \Uparrow #2}
\newcommand\blame{\mathrm{blame}}
\newcommand\perform[2]{#1\left(#2\right)}
\newcommand\handle[2]{\mathbf{handle}\,\{#1\}\,#2}
\newcommand\fori[3]{(#3)_{#1=1\dots #2}}
\newcommand\foriset[3]{\{#3\}_{#1=1\dots #2}}
\newcommand\treturn[1]{\mathbf{return}\,#1}
\newcommand\stepto{\longrightarrow}
\newcommand\stepsto{\stepto^\ast}
\newcommand\subst[3]{#1[#2/#3]}
\newcommand\context[2]{#1[#2]}
\newcommand\xC{\mathcal{C}}
\newcommand\xE{\mathcal{E}}
\newcommand\xP{\mathcal{P}}
\newcommand\bound[1]{\mathbf{bound}(#1)}
\newcommand\cid{\mathrm{id}}
\newcommand\commutel[3]{\mathbf{commutes}^l(#1,#2,#3)}
\newcommand\commuter[3]{\mathbf{commutes}^r(#1,#2,#3)}
\newcommand\cod[1]{\mathrm{cod}(#1)}
\newcommand\codeff[1]{\mathrm{eff}(#1)}
\newcommand\dom[1]{\mathrm{dom}(#1)}
\newcommand\typeof[1]{\mathrm{typeof}(#1)}
\newcommand\dprime{{\prime\prime}}

\newcommand\Term[3]{#1 \vdash #2 : #3}
\newcommand\TermP[4]{#1 \vdash #2 \le #3 : #4}

\newcommand\dhandler{{\color{red}\texttt{library}}}
\newcommand\shandler{{\color{blue}\texttt{library}}}
\newcommand\dclient{{\color{red}\texttt{client}}}
\newcommand\sclient{{\color{blue}\texttt{client}}}

\newcommand\eflog{{[\texttt{Log}]}}
\newcommand\efnone{[]}

\begin{figure}
$$
\begin{array}{l|l}
  \dhandler : (\tyunit \to \tyunit) \to \tystring & \dclient : \tyunit \to \tyunit \\
  \hphantom{\dhandler} : (\tyunit \to \tyunit\,!\,\effany) \to \tystring\,!\,\effany & \hphantom{\dclient} : \tyunit \to \tyunit\,!\,\effany \\
  \shandler : (\tyunit \to \tyunit\,!\,\eflog) \to \tystring \,!\, \efnone & \sclient : \tyunit \to \tyunit\,!\,\eflog
\end{array}
$$
\caption{A library and a client with {\color{red}untyped} and {\color{blue}typed} effects. Unnanotated arrows implicitly produce the dynamic effect $\effany$}
\label{fig:app-example}
\end{figure}

\begin{figure}
$$
\begin{array}{c|cc}
  & \dhandler & \shandler \\
  \hline
  \dclient & \dhandler(\dclient) & \shandler(\dclient) \\
  \sclient & \dhandler(\sclient) & \shandler(\sclient)
\end{array}
$$
\caption{The four possible combinations of typed or untyped library and client}
\label{fig:migration-example}
\end{figure}

\section{Introduction}

Algebraic effects~\citep{plotkin2001semantics} and their handlers are an
approach to computational effects that has seen rapid development in recent
years, inspiring numerous libraries, experimental programming languages,
and even features in industrial programming languages such as WebAssembly, OCaml,
and Haskell.

The problem of typing algebraic effects has been well studied, and solutions
have been implemented in specialized languages with algebraic effects such as
Links, Eff, Koka, and Frank. However, for bigger languages, it remains a
challenge to integrate such \emph{effect systems} with a pre-existing type
system.

Gradual types~\citep{siek2015} provide a lens through which we may study how
the programs using the untyped algebraic effects of today are to interact with
the effect systems of tomorrow. We present a formalization of a
calculus marrying gradual types with algebraic effects.
% (using Core Eff~\citep{bauer2015programming}).

\subsection{Migrating to more statically checked code}

A key motivation for gradual types is to enable gradual migration
towards more statically typed code.

While Multicore OCaml features effect handlers, but lacks \emph{effect typing}:
its type system does not keep track of effects yet.
If a future version of OCaml is to feature effect typing,
it may well become a challenge to migrate existing code that could
not rely on effect typing. If the friction is too great, this may lead
to a schism, splitting OCaml into OCaml-without-effect-typing and
OCaml-with-effect-typing.

For instance, imagine a logging library, implemented as a higher-order function
which handles $\eflog$ effect from its client. Without effect typing, we could
assign the library and the client the types shown at the top of \Cref{fig:app-example}.
With effect typing, we could assign them the types shown at the bottom of that figure,
making explicit the effects that the library consumes and produces.

If the library and the client are large artifacts, it is desirable to
perform this migration from untyped to typed code gradually.
At any point during the migration, the program should remain compilable, and
casts are inserted by the compiler at the interface between the dynamically
typed and statically typed fragments. (\Cref{fig:migration-example})

To ensure that such a migration goes smoothly, the addition of type annotations
should not change the behavior of the program. This property
is called \emph{the gradual guarantee}~\citep{siek2015} or \emph{graduality}.
As we make the types in the program more precise, some type errors may be
revealed, never hidden, and when the program does run successfully, the output
should not change.

\paragraph{Contributions}

\begin{itemize}
  \item We formalize a cast calculus with effect handlers.
    Our work is mechanized in the Agda proof assistant.
  \item We prove that this language satisfies the gradual guarantee
    (\Cref{gradual-guarantee}).
\end{itemize}

% \paragraph{Gradual guarantee} If $M$ is more precise than $M'$ ($M \le M'$),
% and $M$ steps to a value $V$ ($M \to V$), then $M'$ steps to a value $V'$ which
% is less precise than $V$ ($M' \to V' \wedge V \le V'$).
\section{Gradual Eff}

\GEall

\section{Cast calculus with handlers}

Syntax and operational semantics.

Our effect system is based on Eff~\cite{bauer2015programming}.

\subsection{Types}

We distinguish two kinds of types: value types $A$, $B$ (base types, function type, and
dynamic type $\star$) and computation types $P$, $Q$ which pair a value type with an effect (also called \emph{dirt}).

Effects may be static or dynamic. A static effect is a list of operation names,
restricting the operations that a computation may perform. The dynamic effect $\effany$
allows any operation to be performed.

\paragraph{Precision}
In a gradually typed language, types are intuitively ordered by the amount of
static information they give about their inhabitants. This ordering is called
naive subtyping, or \emph{precision}.
We write $a : A \le A'$ to mean that $a$ is a proof that $A$ is more precise than $A'$.
The least precise type is $\star$.
Effects are also ordered by precision, with the least precise effect being $\effany$.
A static effect is only related to itself and to $\effany$.
Effect subtyping can be added as an orthogonal feature.

A proof of precision $a : A \le A'$ serves as a cast between $A$ and $A'$:
either an upcast $+a : A \Rightarrow A'$ or a downcast $-a : A' \Rightarrow A$.

We chose to have a reflexivity rule for all types, which provides an
identity cast for all types. Another design choice would be to only introduce
that rule for base types, which would make proofs of precision $a : A \le A'$
unique for a given $A$ and $A'$. Although reflexivity would remain derivable
for all types, it would be less efficient as a cast.

\subsection{Terms}

Unlike Eff, we do not define fine-grained call-by-value calculus, as that leads
to complications when treating function casts in the proof of the gradual guarantee.

Thus, all terms are treated as computations, with a single judgement $\Gamma \vdash M : P$.
In particular, function applications $N\;M$ and operator applications $M + N$
sequence the computations for their operands, so they must all have the same
effect $E$.

Performing an operation $\mathbf{op}(M)$ requires $\mathbf{op}$ to be allowed
by the effect $E$: either $E$ is a static effect, then $\mathbf{op}$ must occur
in it, or $E$ is a dynamic effect, which allows all operations.

$\mathbf{handle}\,H\,M$ is a handler $H$ applied to a computation $M$.
A handler $H$ consists of one return clause which expects the result of the
handled computation, and zero or more operation clauses.

Value casts and effect casts respectively cast the value type and the effect of a term.
A value cast $[[pa : A => A']]$ transforms values to a more or less precise type.
An effect cast $[[pe : E => E']]$ asserts that a computation with effect $E$
only performs operations allowed by effect $E'$.

A box is a value of the dynamic type. It contains a ground type $G$
(which correspond to a type constructor) and a value of that type.
To cast a function from a non-ground type, $A \to P$ to $\star$,
we will first cast $A \to P$ to the ground type
$[[TYPE ( star -> star ! wstar )]]$ (by casting the domain and codomain individually),
which can then be boxed.

The $\mathbf{blame}$ constructor indicates a type error at run time.

\subsection{Operational semantics}

The behavior of casts depends on the structure of the cast.
A function cast $\pm (a \to b ! e)$
is split into casts on its domain $\mp a$ (note the inverted polarity), codomain $\pm b$, and effect $\pm e$.
An upcast into the dynamic type $+ (a \Uparrow G)$
recursively applies the cast $+ a$ and puts the result in a box.
A downcast from the dynamic type $- (a \Uparrow G)$ compares
the tag $G$ with the tag in the box; if the tags are equal, the value is
unboxed and the cast $- a$ is applied recursively,
otherwise we raise $\mathbf{blame}$.

Effect casts have reduction rules for values and disallowed effects,
but not for allowed effects. When an effect is allowed, it is simply
forwarded to the next handler or effect cast. In that sense,
an effect cast can be thought of as a handler which handles all operations
except the allowed ones.

The reduction rule for handlers is standard. A handler handles operations under an
evaluation context. The closest matching handler is selected by ensuring that
the evaluation context cannot already handle the operation.
Operations may be handled not only by handlers, but also by effect casts.



\begin{figure}
\[
\begin{array}{rcl}
\multicolumn{3}{l}{\fbox{$\bound{\xC}$}} \\
  \bound{\square} & = & \emptyset \\
  \bound{\context{\xP}{\xC}} & = & \bound{\xC} \\
  \bound{\handle{H}{\xC}} & = & \bound{H} \cup \bound{\xC} \\
  \bound{\cast{\xC}{\pm \cty{e}{a}}} & = & \bound{e} \cup \bound{\xC} \\
\multicolumn{3}{l}{\fbox{$\bound{e}$}} \\
  \bound{\pm\, \cid} & = & \emptyset \\
  \bound{+ \Uparrow E} & = & \emptyset \\
  \bound{- \Uparrow E} & = & \mathbf{Op} - E \\
  && \quad \makebox[0pt]{\text{where $\mathbf{Op}$ is the set of all operation symbols} }
\end{array}
\]
\[
\begin{array}{rcl}
\multicolumn{3}{l}{\fbox{$\bound{H}$}} \\
  \bound{\treturn{x}\mapsto N, \fori{i}{n}{\perform{\effop_i}{x,k} \mapsto N_i}}
    &=& \foriset{i}{n}{\effop_i}
\end{array}
\]
\caption{Operations bound by evaluation contexts and by effect casts}
\end{figure}

\paragraph{Soundness} If $[[empty |- M : A ! E]]$, then one of the following holds:
\begin{enumerate}
 \item $[[M --> M']]$ and $[[empty |- M' : A ! E]]$ for some $[[M']]$,
 \item $[[M]]$ is a value,
 \item $[[M]] = [[Ex [ op ( V ) ] ]]$ for some $[[Ex]]$, $[[op in E]]$, and $[[V]]$,
 \item $[[M]] = [[Ex [ blame ] ]]$ for some $[[Ex]]$.
\end{enumerate}

\section{Gradual guarantee}

If a term $M^\prime$ is less precise than $M$ and $M$ evaluates to $V$,
then $M^\prime$ evaluates to some $V^\prime$ less precise than $V$.

\newcommand\wwedge{\quad\wedge\quad}

\[
\begin{array}{rrcl}
  & \TermP{}{M}{M^\prime}{p} & \wedge & M \stepsto V
\\ \implies \exists V^\prime , & \TermP{}{V}{V^\prime}{p} & \wedge & M^\prime \stepsto V^\prime
\end{array}
\]

Simulation lemma (\Cref{fig:sim}): If $M^\prime$ is less precise than $M$, and $M$ takes one step to $N$,
then $M^\prime$ steps (in possibly many steps) to some $N^\prime$ less precise than $N$.

\[
\begin{array}{rrcl}
  & \TermP{}{M}{M^\prime}{p} & \wedge & M \stepto N
\\ \implies \exists N^\prime , & \TermP{}{N}{N^\prime}{p} & \wedge & M^\prime \stepsto N^\prime
\end{array}
\]

Catchup lemma (\Cref{fig:catchup}): if $M^\prime$ is less precise than a value $V$, then $M^\prime$ steps
to a value $V^\prime$ less precise than $V$.

\[
\begin{array}{rrcl}
  & \TermP{}{V}{M^\prime}{p} & &
\\ \implies \exists V^\prime , & \TermP{}{V}{V^\prime}{p} & \wedge & M^\prime \stepsto V^\prime
\end{array}
\]

$\beta$ lemma:

\[
\begin{array}{rccccc}
    & [[empty |- fun x . N <= fun x . N' : a0 ! e]]
    & \wedge & [[empty |- V <= V' : a ! e]]
    & \wedge & [[a0 ~~ ( a -> b ! e )]]
\\ \implies \exists [[M']],
    & [[empty |- N [ V / x ] <= M' : b ! e]]
    & \wedge & [[N' [ V' / x ] -->* M']]
    & &
\end{array}
\]

cast lemma:
\[
\begin{array}{rccccc}
    & [[empty |- M <= M' : a ! e]]
    & \wedge & [[cast pa' M --> N]]
    & \wedge & [[commutesl pa' a b]]
\\ \implies \exists [[N']],
    & [[empty |- N <= N' : b ! e]]
    & \wedge & [[M' -->* N']]
    & &
\end{array}
\]

op lemma:
\[
\begin{array}{rccccc}
    & [[empty |- Ex [ op ( V ) ] <= M' : p]]
    & & & &
\\ \implies \exists [[Ex']], [[V']], [[e]],
    & \varnothing \vdash [[Ex]] \le [[Ex']]
    & \wedge & [[empty |- V <= V' : id ! e]]
    & \wedge & [[M' -->* Ex' [ op ( V' ) ] ]]
\end{array}
\]

\begin{figure}
$$
\input{figures/sim}
$$
\caption{Diagram illustrating the simulation lemma}
\label{fig:sim}
\end{figure}

\begin{figure}
$$ \input{figures/catchup} $$
\caption{Diagram illustrating the catchup lemma}
\label{fig:catchup}
\end{figure}
